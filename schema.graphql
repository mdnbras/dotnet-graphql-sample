# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
    mutation: Mutation
}

"Field information"
interface FieldType {
    "The field description"
    description: String
    "The field current state"
    displayState(
        "Array with current field value information"
        currentFieldValues: [FilledField],
        "User persisted card values on conditional"
        useCardValues: Boolean
    ): ConditionFieldActions
    "The field help text"
    helpText: String
    "The field ID"
    id: ID! @deprecated(reason: "Please, use uuid")
    "If the field could be editable"
    isEditable(
        "Slug ID used to share a card on a phase"
        phaseFormId: ID!
    ): Boolean
    "Whether the field is required"
    isRequired: Boolean
    "The field title"
    label: String!
    "Whether the field is minimal"
    minimalView: Boolean
    "Whether the field triggers a condition"
    triggersFieldConditions: Boolean
    "The field type. Valid options: assignee_select, attachment, checklist_horizontal, checklist_vertical, cnpj, connector, cpf, currency, date, datetime, due_date, email, id, label_select, long_text, number, phone, radio_horizontal, radio_vertical, select, short_text, statement, time,dynamic_content"
    type: String
    "The field universally unique ID"
    uuid: ID!
}

"Generic field information"
interface GenericField {
    "Whether all child items must be done to finish the parent item"
    allChildrenMustBeDoneToFinishParent: Boolean
    "Whether it's possible to connect existing items"
    canConnectExisting: Boolean
    "Whether it's possible to connect multiple items"
    canConnectMultiples: Boolean
    "Whether its possible to create new connected items"
    canCreateNewConnected: Boolean
    "Whether a child must exist to finish the parent"
    childMustExistToFinishParent: Boolean
    "Repo (Pipe or Table) representation"
    connectedRepo: PublicRepoUnion
    "Repo (Pipe or Table) representation"
    connected_repo: RepoTypes @deprecated(reason: "connected_repo has been replaced by connectedRepo")
    "The regex used to validate the field value"
    custom_validation: String
    "Whether the field accepts multiple entries"
    is_multiple: Boolean
    "Whether the field is minimal"
    minimal_view: Boolean
    "Whether the field is required"
    required: Boolean
}

"Card field value information"
interface MinimalCardFieldValueInterface {
    "The value of an Attachment, Checklists, Connection or Label field, processed as an array type"
    array_value: [String]
    "Information about the users assigned to the card"
    assignee_values: [User]
    "Information about cards and records connected with the card"
    connectedRepoItems: [PublicRepoItemTypes]
    "The value of a Date, DateTime or DueDate field, processed as a date type"
    date_value: Date
    "The value of a DateTime or DueDate field, processed as a date and time type"
    datetime_value: DateTime
    "Information about the card field"
    field: MinimalField
    "The field float value"
    float_value: Float
    "Information about the card label"
    label_values: [FieldLabel]
    "The field value for show"
    native_value: String
    "The field value prepared for report"
    report_value: String
    "The field value"
    value: String
}

"List of card information"
interface MinimalCardInterface {
    "When the card was created"
    createdAt: DateTime
    "Information about the card creator"
    createdBy: User
    "The card email address"
    emailMessagingAddress: String
    "The card ID"
    id: ID!
    "The card title"
    title: String!
    "The card UUID"
    uuid: String
}

"Field information"
interface MinimalFieldInterface {
    "The field description"
    description: String
    "The field help text"
    help: String
    "The field ID"
    id: ID!
    "field index"
    index: Float
    "field index name"
    index_name: String
    "The field internal ID"
    internal_id: ID!
    "The field title"
    label: String
    "The options of the Checklist, Radio or Select field"
    options: [String]
    "The field type. Valid options: assignee_select, attachment, checklist_horizontal, checklist_vertical, cnpj, connector, cpf, currency, date, datetime, due_date, email, id, label_select, long_text, number, phone, radio_horizontal, radio_vertical, select, short_text, statement, time, formula, dynamic_content"
    type: String
    "The field Universally Unique ID"
    uuid: ID!
}

"Phase information"
interface MinimalPhaseInterface {
    "The phase ID"
    id: ID!
    "The phase name"
    name: String!
}

"List of organization information"
interface OrganizationInterface {
    "Organization billing infos"
    billing: Billing
    "When the organization was created"
    createdAt: DateTime!
    "User that created the organization"
    createdBy: User
    "When the organization was created"
    created_at: DateTime! @deprecated(reason: "This field is deprecated.\n    Use `createdAt` instead.")
    "The organization logo URL"
    customLogoUrl: String
    "The organization logo URL"
    custom_logo_url: String @deprecated(reason: "This field is deprecated.\n    Use `customLogoUrl` instead.")
    freemium: Boolean
    "The organization ID"
    id: ID!
    "Information about the organization members"
    members(limit: Int): [Member]
    "Quantity of members of the organization"
    membersCount: Int
    "Quantity of members of the organization by role"
    membersCountByRole: [Role]
    "The organization name"
    name: String
    "Whether only Admins can create pipes"
    onlyAdminCanCreatePipes: Boolean
    "Whether only Admins can invite new users"
    onlyAdminCanInviteUsers: Boolean
    "Whether only Admins can create pipes"
    only_admin_can_create_pipes: Boolean @deprecated(reason: "This field is deprecated.\n    Use `onlyAdminCanCreatePipes` instead.")
    "Whether only Admins can invite new users"
    only_admin_can_invite_users: Boolean @deprecated(reason: "This field is deprecated.\n    Use `onlyAdminCanInviteUsers` instead.")
    "User permissions for this org"
    permissions: OrganizationPermissionsInternalGQLType
    "Fetches a group of pipes based on arguments"
    pipes(
        anyone_can_create_card: Boolean,
        ids: [ID],
        include_publics: Boolean,
        "The pipes search query"
        name_search: String,
        onlyFullyVisible: Boolean,
        with_permission: String
    ): [Pipe]
    "Quantity of pipes of the organization"
    pipesCount: Int
    planName: String
    "Current user's role in the organization"
    role: String
    "Fetches a group of database tables based on arguments"
    tables(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "The tables search query"
        name_search: String
    ): TableConnection
    "Info on user metadata related to the current organization"
    userMetadata: OrganizationUserMetadata
    "Information about the organization users"
    users(limit: Int): [User]
    "Quantity of members of the organization"
    users_count: Int @deprecated(reason: "This field is deprecated.\n    Use `membersCount` instead.")
    "The organization UUID"
    uuid: ID!
    "Information about the organization Webhooks"
    webhooks: [Webhook]
}

"List of attributtes that is shared between both public and internal api"
interface PipeSharedProperties {
    "The pipe ID"
    id: ID!
    "The total amount of cards not done"
    opened_cards_count: Int
    "The current user role in the pipe"
    role: String
    "The pipe UUID"
    uuid: String
}

"Public form common fields"
interface PublicFormInterface {
    "The message shown to user after submitting the public form"
    afterSubmitMessage: String
    "The background color of the public form (RGB)"
    backgroundColor: String
    "The background image URL of the public form"
    backgroundImage: String
    "The brand color that will be used in the public form (RGB)"
    brandColor: String
    "Whether the public form creator can hide Pipefy's logo"
    canHidePipefyLogo: Boolean
    "Description of the public form"
    description: String
    "Whether to display Pipefy's logo in the public form"
    displayPipefyLogo: Boolean
    id: ID!
    "Logo of the public form"
    logo: String
    "The name of the organization to be shown in the public form"
    organizationName: String
    "Fill again with the same values that were used on the last submission"
    reuseLastSubmissionResponse: Boolean
    "Whether its allowed to submit another response"
    showSubmitAnotherResponseButton: Boolean
    "Text of the submit button on the public form"
    submitButtonText: String
    "Whether the submitter email collection is enabled"
    submitterEmailCollectionEnabled: Boolean
    "The method to ask for the submitter email in the public form"
    submitterEmailCollectionMethod: PublicFormSubmitterEmailCollectionMethod
    submitterEmailField: MinimalField
    "Title of the public form"
    title: String
}

"List of the pipe information."
interface PublicPipeInterface {
    "Whether anyone can create cards in the pipe"
    anyone_can_create_card: Boolean
    "The pipe total cards"
    cards_count: Int
    "Information about the pipe child connections"
    childrenRelations(
        "Return only table relations"
        only_tables: Boolean
    ): [PipeRelation]
    "Id which the Pipe was cloned from"
    clone_from_id: Int
    "The content displayed in the start form button"
    create_card_label: String
    "When the pipe was created"
    created_at: DateTime
    "The pipe's email inbox address"
    emailAddress: String
    "The number used in the pipe SLA"
    expiration_time_by_unit: Int
    "The seconds of the unit used in the pipe SLA"
    expiration_unit: Int
    "Information about the fields conditions"
    fieldConditions: [FieldCondition]
    "Information about the pipe improvement setting"
    improvementSetting: ImprovementSetting
    "When a card was last updated in the pipe"
    last_updated_by_card: DateTime
    "Whether only Admins can delete cards"
    only_admin_can_remove_cards: Boolean
    "Whether only the card assignees can edit it"
    only_assignees_can_edit_cards: Boolean
    "Information about the pipe parent connections"
    parentsRelations: [PipeRelation]
    "Information about the pipe phases"
    phases: [Phase]
    "Information about the pipe preferences"
    preferences: RepoPreference
    "The pipe's reports"
    reports: [PipeReport]
    "Information about the start form fields conditions"
    startFormFieldConditions: [FieldCondition]
    "Information about the start form fields"
    start_form_fields: [PhaseField]
    "The pipe Small Unique ID"
    suid: String
    "Information about the field selected to be the card title"
    title_field: PhaseField
    "Information about the pipe users"
    users(filterUnacceptedInvitation: Boolean): [User]
    "The total users in the pipe"
    users_count: Int
    "The pipe UUID"
    uuid: String
    "Information about the pipe Webhooks"
    webhooks: [Webhook]
}

"Public Repo information"
interface PublicRepoGQLInterface {
    "The creation button label"
    createButtonLabel: String
    "The Repo icon"
    icon: String
    "The Repo name"
    name: String!
    "The Repo UUID"
    uuid: ID!
}

"Public item information"
interface PublicRepoItemInterface {
    "When the record was created"
    created_at: DateTime
    "Information about icon name and color"
    icon: Icon
    "The item ID"
    id: ID!
    "The item path"
    path: String
    "The record status"
    status: TableRecordStatus
    "The item summary layout information"
    summary: [Summary]
    "Information about the repo item attributes summary layout"
    summary_attributes: [Summary]
    "Information about the repo item custom fields summary layout"
    summary_fields: [Summary]
    "The item title"
    title: String!
    "The URL"
    url: String!
    "The item uuid"
    uuid: ID!
}

"Repo information"
interface Repo {
    "Allows anyone to create cards"
    anyone_can_create_card: Boolean
    "Color of pipe/database"
    color: String
    "IDs of all fields in a pipe that trigger conditionals"
    conditionExpressionsFieldIds: [Int]
    "The Repo description"
    description: String
    "The Repo icon"
    icon: String
    "Information about the Repo labels"
    labels: [Label]
    "Information about the Repo members"
    members(limit: Int): [Member]
    "The Repo name"
    name: String!
    "The Repo noun for their registries"
    noun: String!
    "Information about the organization"
    organization: Organization
    "User permissions for this repo"
    permissions: RepoPermissionsInternalGQLType
    "Whether the Repo is public"
    public: Boolean
    "Information about the public form settings"
    publicForm: PublicFormInternal
    "Information about the public form settings"
    publicFormSettings: PublicFormSettings @deprecated(reason: "This field is deprecated. Use `publicForm` instead.")
    "Whether the public form is active"
    public_form: Boolean @deprecated(reason: "This field is deprecated. Use `publicForm { active }` instead.")
    "Whether the public form is active"
    public_form_active: Boolean @deprecated(reason: "This field is deprecated. Use `publicForm { active }` instead.")
    "The repo start form phase id"
    startFormPhaseId: ID
    "Information about the data selected to be shown in the summarized view"
    summary_attributes: [SummaryAttribute]
    "Information about the Repo summary options"
    summary_options: [SummaryGroup]
    "The total users"
    users_count: Int
}

"Repo connection information"
interface RepoConnection {
    "Whether all children must be done to finish the parent"
    allChildrenMustBeDoneToFinishParent: Boolean
    "Whether all children must be done to move the parent"
    allChildrenMustBeDoneToMoveParent: Boolean
    "Whether its possible to connect existing items"
    canConnectExistingItems: Boolean
    "Whether its possible to connect multiple items"
    canConnectMultipleItems: Boolean
    "Whether its possible to create new connected items"
    canCreateNewItems: Boolean
    "Information about the child Repo"
    child: RepoTypes
    "Whether a child must exist to finish the parent"
    childMustExistToFinishParent: Boolean
    "Whether a child must exist to move the parent"
    childMustExistToMoveParent: Boolean
    "The relation ID"
    id: ID!
    "The relation name"
    name: String!
    "Information about the parent Repo"
    parent: RepoTypes
}

"Repo item field information"
interface RepoItemFieldGQLInterface {
    "Repo item (Card or Record) representation"
    connected_repo_items: [RepoItemTypes] @deprecated(reason: "Please, use connectedRepoItems")
    "When the field was filled"
    filled_at: DateTime
    "The searcheable name"
    indexName: String
    "The field name"
    name: String
    "Information about the field's phase"
    phase_field: PhaseField
    "When the field was last updated"
    updated_at: DateTime
}

"The Repo item form"
interface RepoItemFormGQLInterface {
    "The available fields in Pipefy"
    formFields: [RepoItemFieldsTypes]
}

"Importer information"
interface RepoItemsImportationGQLInterface {
    "The importation date of creation"
    createdAt: DateTime
    "The importation creator"
    createdBy: User
    "The importation date of creation formatted"
    dateFormatted: String
    "The importation ID"
    id: ID!
    "The importation status"
    status: String
    "The xlsx file URL"
    url: String
}

"List of user information"
interface UserInterface {
    "The user avatar URL"
    avatarUrl: String
    "The user avatar URL"
    avatar_url: String @deprecated(reason: "avatar_url has been replaced by avatarUrl")
    "Whether the user is confirmed or not"
    confirmed: Boolean!
    "When the user was created"
    createdAt: String!
    "When the user was created"
    created_at: String! @deprecated(reason: "This field is deprecated. Use `createdAt` instead.")
    "The user department key"
    departmentKey: String
    "The user display name"
    displayName: String!
    "The user email"
    email: String!
    "Returns if the user has unread notifications"
    hasUnreadNotifications: Boolean
    "The user ID"
    id: ID!
    "Return the hash reference for intercom"
    intercomHash: String
    "The user intercom reference"
    intercomId: ID
    "Whether the user was invited to register or not"
    invited: Boolean!
    "The user language"
    locale: String
    "The user name"
    name: String
    "Current user permission to this user"
    permissions: UserPermissionsInternalGqlType
    "The user's phone"
    phone: String
    "The user preferences"
    preferences: UserPreference
    "The user template category key"
    signupData: String
    "The user time zone"
    timeZone: String @deprecated(reason: "This field is deprecated. Use `timezone` instead")
    "The user time zone"
    time_zone: String @deprecated(reason: "This field is deprecated. Use `timezone` instead")
    "The user time zone"
    timezone: String
    "The user username"
    username: String!
    "The user UUID"
    uuid: ID!
}

"translation missing: en.api.documentation.auto_fill_field.query"
union AutoFillFieldUnion = AutoFillFieldCollection | AutoFillFieldString

"translation missing: en.api.documentation.unions.public_repo_item.desc"
union PublicRepoItemTypes = PublicCard | PublicTableRecord

"translation missing: en.api.documentation.unions.public_repo.desc"
union PublicRepoUnion = PublicPipe | PublicTable

"It represents a card or a database table record."
union RepoItemFieldsTypes = AssigneeField | AttachmentField | ChecklistHorizontalField | ChecklistVerticalField | CnpjField | ConnectorField | CpfField | CurrencyField | DateField | DatetimeField | DueDateField | DynamicContentField | EmailField | IdField | LabelField | LongTextField | NumberField | PhoneField | RadioHorizontalField | RadioVerticalField | SelectField | ShortTextField | StatementField | TimeField

"translation missing: en.api.documentation.unions.repo_item_form.desc"
union RepoItemFormUnion = CardForm | TableRecordForm

"It represents a card or a database table record."
union RepoItemTypes = Card | TableRecord

"It represents a pipe or a database table."
union RepoTypes = Pipe | Table

"Repo types: Pipe or Table"
union TableConnectedRepoGQLCoreUnionTypes = ConnectedTable | Pipe

"It represents a card or a database table record."
union UpdatedNode = Card | TableRecord

type AppAttachment {
    card_id: ID
    id: ID
    name: String
    suid: String
    url: String
}

"The connection type for AppAttachment."
type AppAttachmentConnection {
    "A list of edges."
    edges: [AppAttachmentEdge]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type AppAttachmentEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: AppAttachment
}

"The assignee field"
type AssigneeField implements FieldType {
    "The field description"
    description: String
    "The field current state"
    displayState(
        "Array with current field value information"
        currentFieldValues: [FilledField],
        "User persisted card values on conditional"
        useCardValues: Boolean
    ): ConditionFieldActions
    "The field help text"
    helpText: String
    "The field ID"
    id: ID! @deprecated(reason: "Please, use uuid")
    "Assignee field initial value"
    initialValue(
        "Array with initial value information"
        initialValues: [FilledField]
    ): [PublicUser]
    "If the field could be editable"
    isEditable(
        "Slug ID used to share a card on a phase"
        phaseFormId: ID!
    ): Boolean
    "Whether the field is required"
    isRequired: Boolean
    "The field title"
    label: String!
    "Information about the members"
    members: [PublicUser] @deprecated(reason: "This argument will be removed in the next update")
    "Whether the field is minimal"
    minimalView: Boolean
    "Whether the field triggers a condition"
    triggersFieldConditions: Boolean
    "The field type. Valid options: assignee_select, attachment, checklist_horizontal, checklist_vertical, cnpj, connector, cpf, currency, date, datetime, due_date, email, id, label_select, long_text, number, phone, radio_horizontal, radio_vertical, select, short_text, statement, time,dynamic_content"
    type: String
    "The field universally unique ID"
    uuid: ID!
}

"Attachment from card"
type Attachment {
    createdAt: Date
    createdBy: User
    field: MinimalField
    path: String
    phase: Phase
    url: String
}

"The attachment field"
type AttachmentField implements FieldType {
    "The attachment field custom validation"
    customValidation: String
    "The field description"
    description: String
    "The field current state"
    displayState(
        "Array with current field value information"
        currentFieldValues: [FilledField],
        "User persisted card values on conditional"
        useCardValues: Boolean
    ): ConditionFieldActions
    "The field help text"
    helpText: String
    "The field ID"
    id: ID! @deprecated(reason: "Please, use uuid")
    "If the field could be editable"
    isEditable(
        "Slug ID used to share a card on a phase"
        phaseFormId: ID!
    ): Boolean
    "Whether the field is required"
    isRequired: Boolean
    "The field title"
    label: String!
    "Whether the field is minimal"
    minimalView: Boolean
    "Whether the field triggers a condition"
    triggersFieldConditions: Boolean
    "The field type. Valid options: assignee_select, attachment, checklist_horizontal, checklist_vertical, cnpj, connector, cpf, currency, date, datetime, due_date, email, id, label_select, long_text, number, phone, radio_horizontal, radio_vertical, select, short_text, statement, time,dynamic_content"
    type: String
    "The field universally unique ID"
    uuid: ID!
}

type AutoFillFieldCollection {
    fieldId: ID!
    value: [String]!
}

type AutoFillFieldString {
    fieldId: ID!
    value: String!
}

"Billing plans notices"
type Billing {
    billingNoticePeriod: Boolean!
    pastDueNoticeAlert: Boolean!
    upgradeOnlyFreePlan: Boolean!
}

"List of card information"
type Card implements MinimalCardInterface {
    "The seconds since the card was created"
    age: Int
    "Information about the assigned users"
    assignees: [User]
    "Information about the attached files"
    attachments: [Attachment]
    "The card total attachments"
    attachments_count: Int!
    "Information about the card's assignees"
    cardAssignees(userId: ID): [CardAssignee]
    "The card total checked items"
    checklist_items_checked_count: Int!
    "The card total checklist items"
    checklist_items_count: Int!
    "Information about the child pipe connections"
    child_relations(child_repo_id: ID): [CardRelationship]
    "Information about the card comments"
    comments: [Comment]
    "The card total comments"
    comments_count: Int!
    "When the card was created"
    createdAt: DateTime
    "Information about the card creator"
    createdBy: User
    "When the card was created"
    created_at: DateTime @deprecated(reason: "created_at has been replaced by createdAt")
    "Information about the card creator"
    created_by: User @deprecated(reason: "created_by has been replaced by createdBy")
    "The email the card creator"
    creatorEmail: String
    "Information about the card lateness"
    currentLateness: cardLateness
    "Information about the card current phase"
    current_phase: Phase
    "The seconds since the card entered current phase"
    current_phase_age: Int
    "Whether the card is done"
    done: Boolean
    "The card due date"
    due_date: DateTime
    "The card email address"
    emailMessagingAddress: String
    "Information about the card expiration"
    expiration: CardExpiration
    "Whether the card is expired"
    expired: Boolean!
    "Information about the card fields"
    fields: [CardField]
    "When the card was finished"
    finished_at: DateTime
    "The card ID"
    id: ID!
    "Information about any inbox email read status"
    inboxEmailsRead: Boolean!
    "Information about the card emails"
    inbox_emails: [InboxEmail]
    "Information about the card labels"
    labels: [Label]
    "Whether the card is late"
    late: Boolean!
    "Whether the card is overdue"
    overdue: Boolean!
    "Information about the parent pipe connections"
    parent_relations(parent_repo_id: ID): [CardRelationship]
    "The card path"
    path: String
    "Information about the phases the card went through"
    phases_history: [PhaseDetail]
    "Information about the pipe"
    pipe: Pipe
    "The card public form submitter email if exists"
    public_form_submitter_email: String
    "Information about the card current Repo"
    repo: RepoTypes @deprecated(reason: "repo is no longer valid for Card")
    "When the card first entered the current phase"
    started_current_phase_at: DateTime
    "Information about the card subtitles"
    subtitles: [CardField]
    "The card Small Unique ID"
    suid: String
    "Information about the card summary layout"
    summary: [Summary]
    "Information about the card attributes summary layout"
    summary_attributes: [Summary]
    "Information about the card custom fields summary layout"
    summary_fields: [Summary]
    "The card title"
    title: String!
    "When the card was last updated"
    updated_at: DateTime
    "The card URL"
    url: String
    "The card Unique UUID"
    uuid: String
}

"Represents an user assigned to a card"
type CardAssignee {
    assignedAt: DateTime!
    id: Int!
}

"The connection type for Card."
type CardConnection {
    "A list of edges."
    edges: [CardEdge]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type CardEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Card
}

"Information on card expiration"
type CardExpiration {
    "Date and time when card has expired"
    expiredAt: DateTime
    "Date and time when card should become expired"
    shouldExpireAt: DateTime
}

"List of the card's field values informations."
type CardField implements MinimalCardFieldValueInterface & RepoItemFieldGQLInterface {
    "The value of an Attachment, Checklists, Connection or Label field, processed as an array type"
    array_value: [String]
    "Information about the users assigned to the card"
    assignee_values: [User]
    "Information about cards and records connected with the card"
    connectedRepoItems: [PublicRepoItemTypes]
    "Repo item (Card or Record) representation"
    connected_repo_items: [RepoItemTypes] @deprecated(reason: "Please, use connectedRepoItems")
    "The value of a Date, DateTime or DueDate field, processed as a date type"
    date_value: Date
    "The value of a DateTime or DueDate field, processed as a date and time type"
    datetime_value: DateTime
    "Information about the card field"
    field: MinimalField
    "When the field was filled"
    filled_at: DateTime
    "The field float value"
    float_value: Float
    "The searcheable name"
    indexName: String
    "Information about the card label"
    label_values: [FieldLabel]
    "The field name"
    name: String
    "The field value for show"
    native_value: String
    "Information about the field's phase"
    phase_field: PhaseField
    "The field value prepared for report"
    report_value: String
    "When the field was last updated"
    updated_at: DateTime
    "The field value"
    value: String
}

"translation missing: en.api.documentation.card_form.description"
type CardForm implements PublicRepoGQLInterface & RepoItemFormGQLInterface {
    "The creation button label"
    createButtonLabel: String
    "The available fields in Pipefy"
    formFields: [RepoItemFieldsTypes]
    "The Repo icon"
    icon: String
    id: ID!
    "The Repo name"
    name: String!
    "The Repo UUID"
    uuid: ID!
}

"Represents a relation's between two cards or a card and a table_record."
type CardRelation {
    "Represents the child card identifier."
    childId: ID!
    "Represents the card relation identifier."
    id: ID!
    "Represents the parent card identifier."
    parentId: ID!
    "Represents the source identifier."
    sourceId: ID!
    """

    Represents if the connection is through a PipeRelation or a Connection Field.

    The possible values are:

    - PipeRelation
    - Field
    """
    sourceType: String
}

"List of the card relation's information."
type CardRelationship {
    "Lookup the connected cards by their identifier."
    cards(done: Boolean): [Card]
    "The relation ID"
    id: ID
    "Represents the chosen name of the relation."
    name: String
    "Lookup the connected pipe by its identifier."
    pipe: Pipe
    "Lookup the connected Pipe or Table."
    repo: RepoTypes
    """

    Represents if the connection is through a PipeRelation or a Connection Field.

    The possible values are:

    - PipeRelation
    - Field
    """
    source_type: String
}

"Cards importer information"
type CardsImportation implements RepoItemsImportationGQLInterface {
    "The importation date of creation"
    createdAt: DateTime
    "The importation creator"
    createdBy: User
    "The importation date of creation formatted"
    dateFormatted: String
    "The importation ID"
    id: ID!
    "The amount of cards imported"
    importedCards: Int
    "The importation status"
    status: String
    "The xlsx file URL"
    url: String
}

"Autogenerated return type of CardsImporter"
type CardsImporterPayload {
    "Returns information about the importation"
    cardsImportation: CardsImportation
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
}

"The horizontal checklist field"
type ChecklistHorizontalField implements FieldType {
    "The field description"
    description: String
    "The field current state"
    displayState(
        "Array with current field value information"
        currentFieldValues: [FilledField],
        "User persisted card values on conditional"
        useCardValues: Boolean
    ): ConditionFieldActions
    "The field help text"
    helpText: String
    "The field ID"
    id: ID! @deprecated(reason: "Please, use uuid")
    "Horizontal checklist field initial value"
    initialValue(
        "Array with initial value information"
        initialValues: [FilledField]
    ): [String]
    "If the field could be editable"
    isEditable(
        "Slug ID used to share a card on a phase"
        phaseFormId: ID!
    ): Boolean
    "Whether the field is required"
    isRequired: Boolean
    "The field title"
    label: String!
    "Whether the field is minimal"
    minimalView: Boolean
    "The horizontal checklist options"
    options: [String]
    "Whether the field triggers a condition"
    triggersFieldConditions: Boolean
    "The field type. Valid options: assignee_select, attachment, checklist_horizontal, checklist_vertical, cnpj, connector, cpf, currency, date, datetime, due_date, email, id, label_select, long_text, number, phone, radio_horizontal, radio_vertical, select, short_text, statement, time,dynamic_content"
    type: String
    "The field universally unique ID"
    uuid: ID!
}

"The vertical checklist field"
type ChecklistVerticalField implements FieldType {
    "The field description"
    description: String
    "The field current state"
    displayState(
        "Array with current field value information"
        currentFieldValues: [FilledField],
        "User persisted card values on conditional"
        useCardValues: Boolean
    ): ConditionFieldActions
    "The field help text"
    helpText: String
    "The field ID"
    id: ID! @deprecated(reason: "Please, use uuid")
    "Vertical checklist field initial value"
    initialValue(
        "Array with initial value information"
        initialValues: [FilledField]
    ): [String]
    "If the field could be editable"
    isEditable(
        "Slug ID used to share a card on a phase"
        phaseFormId: ID!
    ): Boolean
    "Whether the field is required"
    isRequired: Boolean
    "The field title"
    label: String!
    "Whether the field is minimal"
    minimalView: Boolean
    "The vertical checklist options"
    options: [String]
    "Whether the field triggers a condition"
    triggersFieldConditions: Boolean
    "The field type. Valid options: assignee_select, attachment, checklist_horizontal, checklist_vertical, cnpj, connector, cpf, currency, date, datetime, due_date, email, id, label_select, long_text, number, phone, radio_horizontal, radio_vertical, select, short_text, statement, time,dynamic_content"
    type: String
    "The field universally unique ID"
    uuid: ID!
}

"Autogenerated return type of ClonePipes"
type ClonePipesPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Returns information about the pipe"
    pipes: [Pipe]
}

"The CNPJ field"
type CnpjField implements FieldType {
    "The field description"
    description: String
    "The field current state"
    displayState(
        "Array with current field value information"
        currentFieldValues: [FilledField],
        "User persisted card values on conditional"
        useCardValues: Boolean
    ): ConditionFieldActions
    "The field help text"
    helpText: String
    "The field ID"
    id: ID! @deprecated(reason: "Please, use uuid")
    "CNPJ field initial value"
    initialValue(
        "Array with initial value information"
        initialValues: [FilledField]
    ): String
    "If the field could be editable"
    isEditable(
        "Slug ID used to share a card on a phase"
        phaseFormId: ID!
    ): Boolean
    "Whether the field is required"
    isRequired: Boolean
    "The field title"
    label: String!
    "Whether the field is minimal"
    minimalView: Boolean
    "Whether the field triggers a condition"
    triggersFieldConditions: Boolean
    "The field type. Valid options: assignee_select, attachment, checklist_horizontal, checklist_vertical, cnpj, connector, cpf, currency, date, datetime, due_date, email, id, label_select, long_text, number, phone, radio_horizontal, radio_vertical, select, short_text, statement, time,dynamic_content"
    type: String
    "Whether the field value must be unique"
    unique: Boolean
    "The field universally unique ID"
    uuid: ID!
}

"List of comment information."
type Comment {
    "Lookup the comment's creator by its identifier."
    author: User
    "Represents the comment's creator name."
    author_name: String!
    "Represents the comment's creation date and time."
    created_at: DateTime
    "Represents the comment's identifier."
    id: ID
    "Represents the comment text."
    text: String
}

"The condition is criterias that can be set to trigger an automation."
type Condition {
    "The parameters used in the condition."
    expressions: [ConditionExpression]
    "The condition expressions order, defining groups of \"AND\" and \"OR\"."
    expressions_structure: [[ID]]
    "translation missing: en.api.documentation.condition.fields.id"
    id: ID
    "Information about the card or record used as a condition."
    related_cards: [Card]
}

"The condition architecture."
type ConditionExpression {
    "The field ID used in the condition."
    field_address: String
    "The condition ID."
    id: ID
    """

    The condition operation.

    Valid options:
    - equals
    - not_equals
    - present
    - blank
    - string_contains
    - string_not_contains
    - number_greater_than
    - number_less_than
    - date_is_today
    - date_is_yesterday
    - date_in_current_week
    - date_in_last_week
    - date_in_current_month
    - date_in_last_month
    - date_in_current_year
    - date_in_last_year
    - date_is
    - date_is_after
    - date_is_before
    """
    operation: String
    "The number used to arrange condition's expressions in groups of \"AND\" and \"OR\"."
    structure_id: ID
    "The value selected to be compared in the condition."
    value: String
}

"List of fields which need of expecicly conditions."
type ConditionalField {
    "Fields wich must be hidden"
    fieldsToHide: [PhaseField]
}

"List of table information"
type ConnectedTable implements Repo {
    "Allows anyone to create cards"
    anyone_can_create_card: Boolean
    "Information about the database table authorization"
    authorization: TableAuthorization
    "Color of pipe/database"
    color: String
    "IDs of all fields in a pipe that trigger conditionals"
    conditionExpressionsFieldIds: [Int]
    "The content displayed in the start form button"
    create_record_button_label: String
    "The Repo description"
    description: String
    "The Repo icon"
    icon: String
    "The database table ID"
    id: ID!
    "Information about the Repo labels"
    labels: [Label]
    "Information about the Repo members"
    members(limit: Int): [Member]
    "Information about the current user permission"
    my_permissions: TablePermission
    "The Repo name"
    name: String!
    "The Repo noun for their registries"
    noun: String!
    "The orderable fields. Valid options: title, status, created_at, updated_at, finished_at"
    orderableFields: [String]
    "The orderable field types"
    orderableTypes: [String]
    "Information about the organization"
    organization: Organization
    "User permissions for this repo"
    permissions: RepoPermissionsInternalGQLType
    "Whether the Repo is public"
    public: Boolean
    "Information about the public form settings"
    publicForm: PublicFormInternal
    "Information about the public form settings"
    publicFormSettings: PublicFormSettings @deprecated(reason: "This field is deprecated. Use `publicForm` instead.")
    "Whether the public form is active"
    public_form: Boolean @deprecated(reason: "This field is deprecated. Use `publicForm { active }` instead.")
    "Whether the public form is active"
    public_form_active: Boolean @deprecated(reason: "This field is deprecated. Use `publicForm { active }` instead.")
    "The repo start form phase id"
    startFormPhaseId: ID
    "Information about the database table statuses"
    statuses: [TableRecordStatus]
    "Information about the data selected to be shown in the summarized view"
    summary_attributes: [SummaryAttribute]
    "Information about the Repo summary options"
    summary_options: [SummaryGroup]
    "Information about the database table fields"
    table_fields: [TableField]
    "Fetches a group of records based on arguments"
    table_records(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int
    ): TableRecordConnection
    "The database table total records"
    table_records_count: Int
    "Information about the field selected to be the record title"
    title_field: TableField
    "The database table URL"
    url: String
    "The total users"
    users_count: Int
    "The database uuid"
    uuid: ID
}

"The connection field"
type ConnectorField implements FieldType {
    "Whether can connect with existing items"
    canConnectExisting: Boolean
    "Whether is possible to connect with multiple items"
    canConnectMultiples: Boolean
    "Whether is possible to create new connected items"
    canCreateNewConnected: Boolean
    "Repo (Pipe or Table) representation"
    connectedRepo: PublicRepoUnion
    "The field description"
    description: String
    "The field current state"
    displayState(
        "Array with current field value information"
        currentFieldValues: [FilledField],
        "User persisted card values on conditional"
        useCardValues: Boolean
    ): ConditionFieldActions
    "The field help text"
    helpText: String
    "The field ID"
    id: ID! @deprecated(reason: "Please, use uuid")
    "Connection field initial value"
    initialValue(
        "Array with initial value information"
        initialValues: [FilledField]
    ): [PublicRepoItem]
    "If the field could be editable"
    isEditable(
        "Slug ID used to share a card on a phase"
        phaseFormId: ID!
    ): Boolean
    "Whether the field is required"
    isRequired: Boolean
    "The field title"
    label: String!
    "Whether the field is minimal"
    minimalView: Boolean
    "Whether the field triggers a condition"
    triggersFieldConditions: Boolean
    "The field type. Valid options: assignee_select, attachment, checklist_horizontal, checklist_vertical, cnpj, connector, cpf, currency, date, datetime, due_date, email, id, label_select, long_text, number, phone, radio_horizontal, radio_vertical, select, short_text, statement, time,dynamic_content"
    type: String
    "The field universally unique ID"
    uuid: ID!
}

"The CPF field"
type CpfField implements FieldType {
    "The field description"
    description: String
    "The field current state"
    displayState(
        "Array with current field value information"
        currentFieldValues: [FilledField],
        "User persisted card values on conditional"
        useCardValues: Boolean
    ): ConditionFieldActions
    "The field help text"
    helpText: String
    "The field ID"
    id: ID! @deprecated(reason: "Please, use uuid")
    "CPF field initial value"
    initialValue(
        "Array with initial value information"
        initialValues: [FilledField]
    ): String
    "If the field could be editable"
    isEditable(
        "Slug ID used to share a card on a phase"
        phaseFormId: ID!
    ): Boolean
    "Whether the field is required"
    isRequired: Boolean
    "The field title"
    label: String!
    "Whether the field is minimal"
    minimalView: Boolean
    "Whether the field triggers a condition"
    triggersFieldConditions: Boolean
    "The field type. Valid options: assignee_select, attachment, checklist_horizontal, checklist_vertical, cnpj, connector, cpf, currency, date, datetime, due_date, email, id, label_select, long_text, number, phone, radio_horizontal, radio_vertical, select, short_text, statement, time,dynamic_content"
    type: String
    "Whether the field value must be unique"
    unique: Boolean
    "The field universally unique ID"
    uuid: ID!
}

"Autogenerated return type of CreateCard"
type CreateCardPayload {
    "Returns information about the card"
    card: Card
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
}

"Autogenerated return type of CreateCardRelation"
type CreateCardRelationPayload {
    "Returns information about the cardRelation"
    cardRelation: CardRelation
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
}

"Autogenerated return type of CreateComment"
type CreateCommentPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Returns information about the comment"
    comment: Comment
}

"Autogenerated return type of CreateInboxEmail"
type CreateInboxEmailPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Returns information about the inbox_email"
    inbox_email: InboxEmail
}

"Autogenerated return type of CreateLabel"
type CreateLabelPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Returns information about the label"
    label: Label
}

"Autogenerated return type of CreateOrganization"
type CreateOrganizationPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Returns information about the organization"
    organization: Organization
}

"Autogenerated return type of CreateOrganizationWebhook"
type CreateOrganizationWebhookPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Returns information about the webhook"
    webhook: Webhook
}

"Autogenerated return type of CreatePhaseField"
type CreatePhaseFieldPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Returns information about the phase field"
    phase_field: PhaseField
}

"Autogenerated return type of CreatePhase"
type CreatePhasePayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Returns information about the phase"
    phase: Phase
}

"Autogenerated return type of CreatePipe"
type CreatePipePayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Returns information about the pipe"
    pipe: Pipe
}

"Autogenerated return type of CreatePipeRelation"
type CreatePipeRelationPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Returns information about the pipe relation"
    pipeRelation: PipeRelation
}

"Autogenerated return type of CreatePresignedUrlForPipePdfTemplate"
type CreatePresignedUrlForPipePdfTemplatePayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "The presigned url"
    url: String
}

"Autogenerated return type of CreatePresignedUrl"
type CreatePresignedUrlPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "The download url"
    downloadUrl: String
    "The presigned url"
    url: String
}

"Autogenerated return type of CreateTableField"
type CreateTableFieldPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Returns information about the table fields"
    table_field: TableField
}

"Autogenerated return type of CreateTable"
type CreateTablePayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Returns information about the table"
    table: Table
}

"Autogenerated return type of CreateTableRecordInRestrictedTable"
type CreateTableRecordInRestrictedTablePayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Returns information about the record"
    tableRecord: PublicTableRecord
}

"Autogenerated return type of CreateTableRecord"
type CreateTableRecordPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Returns information about the record"
    table_record: TableRecord
}

"Autogenerated return type of CreateTableRelation"
type CreateTableRelationPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Returns information about the table relation"
    tableRelation: TableRelation
}

"Autogenerated return type of CreateWebhook"
type CreateWebhookPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Returns information about the webhook"
    webhook: Webhook
}

"The currency field"
type CurrencyField implements FieldType {
    "The field description"
    description: String
    "The field current state"
    displayState(
        "Array with current field value information"
        currentFieldValues: [FilledField],
        "User persisted card values on conditional"
        useCardValues: Boolean
    ): ConditionFieldActions
    "The field help text"
    helpText: String
    "The field ID"
    id: ID! @deprecated(reason: "Please, use uuid")
    "Currency field initial value"
    initialValue(
        "Array with initial value information"
        initialValues: [FilledField]
    ): Float
    "If the field could be editable"
    isEditable(
        "Slug ID used to share a card on a phase"
        phaseFormId: ID!
    ): Boolean
    "Whether the field is required"
    isRequired: Boolean
    "The field title"
    label: String!
    "Whether the field is minimal"
    minimalView: Boolean
    "Whether the field triggers a condition"
    triggersFieldConditions: Boolean
    "The field type. Valid options: assignee_select, attachment, checklist_horizontal, checklist_vertical, cnpj, connector, cpf, currency, date, datetime, due_date, email, id, label_select, long_text, number, phone, radio_horizontal, radio_vertical, select, short_text, statement, time,dynamic_content"
    type: String
    "Whether the field value must be unique"
    unique: Boolean
    "The field universally unique ID"
    uuid: ID!
}

"The date field"
type DateField implements FieldType {
    "The field description"
    description: String
    "The field current state"
    displayState(
        "Array with current field value information"
        currentFieldValues: [FilledField],
        "User persisted card values on conditional"
        useCardValues: Boolean
    ): ConditionFieldActions
    "The field help text"
    helpText: String
    "The field ID"
    id: ID! @deprecated(reason: "Please, use uuid")
    "Date field initial value"
    initialValue(
        "Array with initial value information"
        initialValues: [FilledField]
    ): Date
    "If the field could be editable"
    isEditable(
        "Slug ID used to share a card on a phase"
        phaseFormId: ID!
    ): Boolean
    "Whether the field is required"
    isRequired: Boolean
    "The field title"
    label: String!
    "Whether the field is minimal"
    minimalView: Boolean
    "Whether the field triggers a condition"
    triggersFieldConditions: Boolean
    "The field type. Valid options: assignee_select, attachment, checklist_horizontal, checklist_vertical, cnpj, connector, cpf, currency, date, datetime, due_date, email, id, label_select, long_text, number, phone, radio_horizontal, radio_vertical, select, short_text, statement, time,dynamic_content"
    type: String
    "Whether the field value must be unique"
    unique: Boolean
    "The field universally unique ID"
    uuid: ID!
}

"The date time field"
type DatetimeField implements FieldType {
    "The field description"
    description: String
    "The field current state"
    displayState(
        "Array with current field value information"
        currentFieldValues: [FilledField],
        "User persisted card values on conditional"
        useCardValues: Boolean
    ): ConditionFieldActions
    "The field help text"
    helpText: String
    "The field ID"
    id: ID! @deprecated(reason: "Please, use uuid")
    "Date time field initial value"
    initialValue(
        "Array with initial value information"
        initialValues: [FilledField]
    ): DateTime
    "If the field could be editable"
    isEditable(
        "Slug ID used to share a card on a phase"
        phaseFormId: ID!
    ): Boolean
    "Whether the field is required"
    isRequired: Boolean
    "The field title"
    label: String!
    "Whether the field is minimal"
    minimalView: Boolean
    "Whether the field triggers a condition"
    triggersFieldConditions: Boolean
    "The field type. Valid options: assignee_select, attachment, checklist_horizontal, checklist_vertical, cnpj, connector, cpf, currency, date, datetime, due_date, email, id, label_select, long_text, number, phone, radio_horizontal, radio_vertical, select, short_text, statement, time,dynamic_content"
    type: String
    "Whether the field value must be unique"
    unique: Boolean
    "The field universally unique ID"
    uuid: ID!
}

"Autogenerated return type of DeleteCard"
type DeleteCardPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Whether the mutation was successful"
    success: Boolean
}

"Autogenerated return type of DeleteComment"
type DeleteCommentPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Whether the mutation was successful"
    success: Boolean
}

"Autogenerated return type of DeleteFieldCondition"
type DeleteFieldConditionPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Whether the mutation was successful"
    success: Boolean
}

"Autogenerated return type of DeleteInboxEmail"
type DeleteInboxEmailPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Whether the mutation was successful"
    success: Boolean
}

"Autogenerated return type of DeleteLabel"
type DeleteLabelPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Whether the mutation was successful"
    success: Boolean
}

"Autogenerated return type of DeleteOrganization"
type DeleteOrganizationPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Whether the mutation was successful"
    success: Boolean
}

"Autogenerated return type of DeleteOrganizationWebhookGQLMutation"
type DeleteOrganizationWebhookGQLMutationPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Whether the mutation was successful"
    success: Boolean
}

"Autogenerated return type of DeletePhaseField"
type DeletePhaseFieldPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Whether the mutation was successful"
    success: Boolean!
}

"Autogenerated return type of DeletePhase"
type DeletePhasePayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Whether the mutation was successful"
    success: Boolean
}

"Autogenerated return type of DeletePipe"
type DeletePipePayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Whether the mutation was successful"
    success: Boolean
}

"Autogenerated return type of DeletePipeRelation"
type DeletePipeRelationPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Whether the mutation was successful"
    success: Boolean
}

"Autogenerated return type of DeleteTableField"
type DeleteTableFieldPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Whether the mutation was successful"
    success: Boolean
}

"Autogenerated return type of DeleteTable"
type DeleteTablePayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Whether the mutation was successful"
    success: Boolean
}

"Autogenerated return type of DeleteTableRecord"
type DeleteTableRecordPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Whether the mutation was successful"
    success: Boolean
}

"Autogenerated return type of DeleteTableRelation"
type DeleteTableRelationPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Whether the mutation was successful"
    success: Boolean
}

"Autogenerated return type of DeleteWebhook"
type DeleteWebhookPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Whether the mutation was successful"
    success: Boolean
}

"The due date field"
type DueDateField implements FieldType {
    "The field description"
    description: String
    "The field current state"
    displayState(
        "Array with current field value information"
        currentFieldValues: [FilledField],
        "User persisted card values on conditional"
        useCardValues: Boolean
    ): ConditionFieldActions
    "The field help text"
    helpText: String
    "The field ID"
    id: ID! @deprecated(reason: "Please, use uuid")
    "Due date field initial value"
    initialValue(
        "Array with initial value information"
        initialValues: [FilledField]
    ): DateTime
    "If the field could be editable"
    isEditable(
        "Slug ID used to share a card on a phase"
        phaseFormId: ID!
    ): Boolean
    "Whether the field is required"
    isRequired: Boolean
    "The field title"
    label: String!
    "Whether the field is minimal"
    minimalView: Boolean
    "Whether the field triggers a condition"
    triggersFieldConditions: Boolean
    "The field type. Valid options: assignee_select, attachment, checklist_horizontal, checklist_vertical, cnpj, connector, cpf, currency, date, datetime, due_date, email, id, label_select, long_text, number, phone, radio_horizontal, radio_vertical, select, short_text, statement, time,dynamic_content"
    type: String
    "Whether the field value must be unique"
    unique: Boolean
    "The field universally unique ID"
    uuid: ID!
}

"The dynamic content field"
type DynamicContentField implements FieldType {
    "The field description"
    description: String
    "The field current state"
    displayState(
        "Array with current field value information"
        currentFieldValues: [FilledField],
        "User persisted card values on conditional"
        useCardValues: Boolean
    ): ConditionFieldActions
    "The field help text"
    helpText: String
    "The field ID"
    id: ID! @deprecated(reason: "Please, use uuid")
    "If the field could be editable"
    isEditable(
        "Slug ID used to share a card on a phase"
        phaseFormId: ID!
    ): Boolean
    "Whether the field is required"
    isRequired: Boolean
    "The field title"
    label: String!
    "Whether the field is minimal"
    minimalView: Boolean
    "Whether the field triggers a condition"
    triggersFieldConditions: Boolean
    "The field type. Valid options: assignee_select, attachment, checklist_horizontal, checklist_vertical, cnpj, connector, cpf, currency, date, datetime, due_date, email, id, label_select, long_text, number, phone, radio_horizontal, radio_vertical, select, short_text, statement, time,dynamic_content"
    type: String
    "The field universally unique ID"
    uuid: ID!
}

"List of Email Attachments."
type EmailAttachment {
    "Represents the file url."
    fileUrl: String
    "Represents the name of the file of the attachment."
    filename: String
    "Represents each email attachment identifier."
    id: ID!
    "Represents the full path of the file url."
    public_url: String
}

"The email field"
type EmailField implements FieldType {
    "The field description"
    description: String
    "The field current state"
    displayState(
        "Array with current field value information"
        currentFieldValues: [FilledField],
        "User persisted card values on conditional"
        useCardValues: Boolean
    ): ConditionFieldActions
    "The field help text"
    helpText: String
    "The field ID"
    id: ID! @deprecated(reason: "Please, use uuid")
    "Email field initial value"
    initialValue(
        "Array with initial value information"
        initialValues: [FilledField]
    ): String
    "If the field could be editable"
    isEditable(
        "Slug ID used to share a card on a phase"
        phaseFormId: ID!
    ): Boolean
    "Whether the field is required"
    isRequired: Boolean
    "The field title"
    label: String!
    "Whether the field is minimal"
    minimalView: Boolean
    "Whether the field triggers a condition"
    triggersFieldConditions: Boolean
    "The field type. Valid options: assignee_select, attachment, checklist_horizontal, checklist_vertical, cnpj, connector, cpf, currency, date, datetime, due_date, email, id, label_select, long_text, number, phone, radio_horizontal, radio_vertical, select, short_text, statement, time,dynamic_content"
    type: String
    "Whether the field value must be unique"
    unique: Boolean
    "The field universally unique ID"
    uuid: ID!
}

"translation missing: en.api.documentation.errors.query"
type Errors {
    index: Int
    message: String
}

"Autogenerated return type of ExportPipeReport"
type ExportPipeReportPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Returns information on the report export"
    pipeReportExport: PipeReportExport
}

"translation missing: en.api.documentation.field_condition.description"
type FieldCondition {
    "translation missing: en.api.documentation.field_condition.actions"
    actions: [FieldConditionAction]
    "translation missing: en.api.documentation.field_condition.condition"
    condition: Condition
    "translation missing: en.api.documentation.field_condition.id"
    id: ID
    "translation missing: en.api.documentation.field_condition.index"
    isTrueFor(cardId: ID!): Boolean
    "translation missing: en.api.documentation.field_condition.name"
    name: String
    "translation missing: en.api.documentation.field_condition.phase"
    phase: Phase
}

"translation missing: en.api.documentation.field_condition_action.description"
type FieldConditionAction {
    "translation missing: en.api.documentation.field_condition_action.action"
    actionId: String
    "translation missing: en.api.documentation.field_condition_action.id"
    id: ID
    "translation missing: en.api.documentation.field_condition_action.field"
    phase: Phase
    "translation missing: en.api.documentation.field_condition_action.field"
    phaseField: PhaseField
    "translation missing: en.api.documentation.field_condition_action.field"
    phaseFieldId: ID @deprecated(reason: "phaseFieldId is deprecated. Use phaseField instead.")
    "When condition evaluator"
    whenEvaluator: Boolean
}

"List of the label information."
type FieldLabel {
    "Represents the color used in the label using a hexadecimal string."
    color: String
    "Represents the label identifier."
    id: ID
    "Represents the label name."
    name: String
}

"The field map represents the field ID of the father-card and the related field ID of the child-card."
type FieldMap {
    "The field ID of the father-card."
    fieldId: ID!
    "The field ID of the father-card."
    field_id: ID! @deprecated(reason: "field_id is deprecated, use fieldId instead")
    """

    How the value is going to be parsed:

    Valid options:
    - fixed_value: uses a fix value for the field.
    - copy_from: copies the value of the father-card.
    """
    inputMode: String!
    "The field ID of the child-card."
    value: String!
}

"Shows improvement's help link information"
type HelpLink {
    "Represents the link description"
    description: String
    "Represents the link icon"
    icon: String
    "Represents the link identifier"
    id: ID!
    "Whether the link opens in a new tab"
    newTab: Boolean
    "Represents the link title"
    title: String
    "Represents the link url"
    url: String
}

type Icon {
    color: String!
    name: String!
}

"The ID field"
type IdField implements FieldType {
    "The field description"
    description: String
    "The field current state"
    displayState(
        "Array with current field value information"
        currentFieldValues: [FilledField],
        "User persisted card values on conditional"
        useCardValues: Boolean
    ): ConditionFieldActions
    "The field display value"
    displayValue: ID!
    "The field help text"
    helpText: String
    "The field ID"
    id: ID! @deprecated(reason: "Please, use uuid")
    isEditable(
        "Slug ID used to share a card on a phase"
        phaseFormId: ID!
    ): Boolean
    "Whether the field is required"
    isRequired: Boolean
    "The field title"
    label: String!
    "Whether the field is minimal"
    minimalView: Boolean
    triggersFieldConditions: Boolean
    "The field type. Valid options: assignee_select, attachment, checklist_horizontal, checklist_vertical, cnpj, connector, cpf, currency, date, datetime, due_date, email, id, label_select, long_text, number, phone, radio_horizontal, radio_vertical, select, short_text, statement, time,dynamic_content"
    type: String
    "The field universally unique ID"
    uuid: ID!
}

"List of improvements by pipe"
type Improvement {
    "The improvement's app"
    app: PlatformApp
    "The improvement's view state"
    clicked: Boolean!
    "The improvement's dismiss state"
    dismissed: Boolean!
    "The improvement's view state"
    enabled: Boolean!
    "Represents each improvement's identifier"
    id: ID!
    "The improvement's help link"
    link: HelpLink
    "The improvement's dismiss state"
    viewed: Boolean!
}

"Show a pipe's improvement setting"
type ImprovementSetting {
    "Represents improvement setting's description"
    description: ID!
    "Represents improvement setting's identifier"
    id: ID!
    "List all improvements of an improvement setting"
    improvements: [Improvement]
    "Represents the improvement setting's title"
    title: ID!
}

"List of the Inbox Email information."
type InboxEmail {
    "Lookup the email's attachments by its identifier."
    attachments: [EmailAttachment]
    "Represents Inbox Email 'BCC' email addresses."
    bcc: [String]
    "Represents Inbox Email body, with any eventual previous replies removed."
    body: String
    "Lookup the card, from which the Inbox Email was sent, by its identifier."
    card: Card
    "Represents Inbox Email 'CC' email addresses."
    cc: [String]
    "translation missing: en.api.documentation.inbox_email.fields.clean_body"
    clean_body: String @deprecated(reason: "Use the body attribute instead")
    "Represents Inbox Email's clean HTML, only filtering the invalid or malicious characters and tags."
    clean_html: String
    "Represents Inbox Email's clean text, only filtering the invalid or malicious characters and tags."
    clean_text: String
    "translation missing: en.api.documentation.inbox_email.fields.created_at"
    created_at: DateTime
    "Represents Inbox Email sender email address."
    from: String
    "Represents Inbox Email sender's name."
    fromName: String
    "Represents Inbox Email sender's name."
    from_name: String @deprecated(reason: "please, use fromName")
    "Represents each email's identifier."
    id: ID!
    "Represents Inbox Email's primary email addresses destination."
    main_to: String
    "Represents the Inbox Email answer message identifier."
    message_id: String
    "Lookup the pipe, from which the Inbox Email was sent, by its identifier."
    pipe: Pipe
    "translation missing: en.api.documentation.inbox_email.fields.raw_body"
    raw_body: String @deprecated(reason: "Use the body attribute instead")
    "Represents Inbox Email raw headers."
    raw_headers: String
    "Represents Inbox Email raw HTML format, only filtering invalid characters."
    raw_html: String
    "translation missing: en.api.documentation.inbox_email.fields.raw_text"
    raw_text: String @deprecated(reason: "Use the clean text attribute instead")
    "Indicates if this email was sent using an automation"
    sent_via_automation: Boolean
    """

    Represents Inbox Email state, which can be:

    * 0 - Pending
    * 1 - Processing
    * 2 - Processed
    * 3 - Failed
    """
    state: String
    "Represents Inbox Email subject."
    subject: String
    "Represents Inbox Email receiver email address."
    to: [String]
    type: InboxEmailType
    "Represents last Inbox Email update date and time."
    updated_at: DateTime
    "Lookup the email's creator."
    user: User
}

"Autogenerated return type of InviteMembers"
type InviteMembersPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Returns possible errors in the mutation"
    errors: [Errors]
    "Returns information about the new users"
    users: [User]
}

"List of the label information."
type Label {
    "Represents the color used in the label using a hexadecimal string."
    color: String
    "Represents the label identifier."
    id: ID!
    "Represents the label name."
    name: String
}

"The label field"
type LabelField implements FieldType {
    "The field description"
    description: String
    "The field current state"
    displayState(
        "Array with current field value information"
        currentFieldValues: [FilledField],
        "User persisted card values on conditional"
        useCardValues: Boolean
    ): ConditionFieldActions
    "The field help text"
    helpText: String
    "The field ID"
    id: ID! @deprecated(reason: "Please, use uuid")
    "Label field initial value"
    initialValue(
        "Array with initial value information"
        initialValues: [FilledField]
    ): [Label]
    "If the field could be editable"
    isEditable(
        "Slug ID used to share a card on a phase"
        phaseFormId: ID!
    ): Boolean
    "Whether the field is required"
    isRequired: Boolean
    "The field title"
    label: String!
    "Array with label information"
    labels: [Label]
    "Whether the field is minimal"
    minimalView: Boolean
    "Whether the field triggers a condition"
    triggersFieldConditions: Boolean
    "The field type. Valid options: assignee_select, attachment, checklist_horizontal, checklist_vertical, cnpj, connector, cpf, currency, date, datetime, due_date, email, id, label_select, long_text, number, phone, radio_horizontal, radio_vertical, select, short_text, statement, time,dynamic_content"
    type: String
    "The field universally unique ID"
    uuid: ID!
}

"The long text field"
type LongTextField implements FieldType {
    "The field description"
    description: String
    "The field current state"
    displayState(
        "Array with current field value information"
        currentFieldValues: [FilledField],
        "User persisted card values on conditional"
        useCardValues: Boolean
    ): ConditionFieldActions
    "The field help text"
    helpText: String
    "The field ID"
    id: ID! @deprecated(reason: "Please, use uuid")
    "Long text field initial value"
    initialValue(
        "Array with initial value information"
        initialValues: [FilledField]
    ): String
    "If the field could be editable"
    isEditable(
        "Slug ID used to share a card on a phase"
        phaseFormId: ID!
    ): Boolean
    "Whether the field is required"
    isRequired: Boolean
    "The field title"
    label: String!
    "Whether the field is minimal"
    minimalView: Boolean
    "Whether the field triggers a condition"
    triggersFieldConditions: Boolean
    "The field type. Valid options: assignee_select, attachment, checklist_horizontal, checklist_vertical, cnpj, connector, cpf, currency, date, datetime, due_date, email, id, label_select, long_text, number, phone, radio_horizontal, radio_vertical, select, short_text, statement, time,dynamic_content"
    type: String
    "The field universally unique ID"
    uuid: ID!
}

"Member information"
type Member {
    """

    The user role name

    Valid roles:
    1. Organization:
    - admin: Team admin, can view/join all pipes and access/manage the team settings;
    - normal: Team member, can view and join all public pipes;
    - company_guest: Team guest, can only create cards in authorized forms. No access to pipes or databases. Can become a Member by creating a pipe or being added to one.
    - external_guest: External guest, can only create cards in authorized forms. No access to pipes or databases.

    2. Pipe:
    - admin: Pipe admin, can create and edit cards as well as manage the pipe settings;
    - member: Pipe member, can create new cards as well as access the existing ones to edit and move them across the pipe;
    - creator: Pipe start form only, has limited access to the pipe - can create cards;
    - my_cards_only: Pipe restricted view, can create new cards but is only allowed to view/edit cards created by or assigned to him;
    - read_and_comment: Pipe read only, can view the cards and add comments.

    3. Database Table:
    - admin: Table admin, can create an edit records, edit the table and its settings;
    - member: Table member, can view and create records (if authorized on the settings).
    """
    role_name: String!
    "The user information"
    user: User
}

"Field information"
type MinimalField implements MinimalFieldInterface {
    "The field description"
    description: String
    "The field help text"
    help: String
    "The field ID"
    id: ID!
    "field index"
    index: Float
    "field index name"
    index_name: String
    "The field internal ID"
    internal_id: ID!
    "The field title"
    label: String
    "The options of the Checklist, Radio or Select field"
    options: [String]
    "The field type. Valid options: assignee_select, attachment, checklist_horizontal, checklist_vertical, cnpj, connector, cpf, currency, date, datetime, due_date, email, id, label_select, long_text, number, phone, radio_horizontal, radio_vertical, select, short_text, statement, time, formula, dynamic_content"
    type: String
    "The field Universally Unique ID"
    uuid: ID!
}

"Autogenerated return type of MoveCardToPhase"
type MoveCardToPhasePayload {
    "Returns information about the card"
    card: Card
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
}

"The root query for implementing GraphQL mutations"
type Mutation {
    "Create new cards from a xlsx file"
    cardsImporter(input: CardsImporterInput!): CardsImporterPayload
    "Clones a pipe"
    clonePipes(input: ClonePipesInput!): ClonePipesPayload
    configurePublicPhaseFormLink(input: configurePublicPhaseFormLinkInput!): PublicPhaseFormLink
    "Creates a card"
    createCard(input: CreateCardInput!): CreateCardPayload
    "Creates a card relation"
    createCardRelation(input: CreateCardRelationInput!): CreateCardRelationPayload
    "Creates a comment"
    createComment(input: CreateCommentInput!): CreateCommentPayload
    "Creates a field condition"
    createFieldCondition(input: createFieldConditionInput!): createFieldConditionPayload @deprecated(reason: "Mutation will be removed in the next update")
    "Creates an email"
    createInboxEmail(input: CreateInboxEmailInput!): CreateInboxEmailPayload
    "Creates a label"
    createLabel(input: CreateLabelInput!): CreateLabelPayload
    "Creates an organization"
    createOrganization(input: CreateOrganizationInput!): CreateOrganizationPayload
    "Creates an organization-level webhook"
    createOrganizationWebhook(input: CreateOrganizationWebhookInput!): CreateOrganizationWebhookPayload
    "Creates a phase"
    createPhase(input: CreatePhaseInput!): CreatePhasePayload
    "Creates a phase field"
    createPhaseField(input: CreatePhaseFieldInput!): CreatePhaseFieldPayload
    "Creates a pipe"
    createPipe(input: CreatePipeInput!): CreatePipePayload
    "Creates a pipe relation"
    createPipeRelation(input: CreatePipeRelationInput!): CreatePipeRelationPayload
    "Returns a temporary S3 presigned url to upload a file"
    createPresignedUrl(input: CreatePresignedUrlInput!): CreatePresignedUrlPayload
    "Returns a temporary S3 presigned url to upload a pdf template image"
    createPresignedUrlForPipePdfTemplate(input: CreatePresignedUrlForPipePdfTemplateInput!): CreatePresignedUrlForPipePdfTemplatePayload
    "Creates a table"
    createTable(input: CreateTableInput!): CreateTablePayload
    "Creates a table field"
    createTableField(input: CreateTableFieldInput!): CreateTableFieldPayload
    "Creates a record"
    createTableRecord(input: CreateTableRecordInput!): CreateTableRecordPayload
    "Creates a record in a private table"
    createTableRecordInRestrictedTable(input: CreateTableRecordInRestrictedTableInput!): CreateTableRecordInRestrictedTablePayload
    "Creates a table relation"
    createTableRelation(input: CreateTableRelationInput!): CreateTableRelationPayload @deprecated(reason: "Mutation will be removed in the next update")
    "Creates a webhook at a pipe or table level"
    createWebhook(input: CreateWebhookInput!): CreateWebhookPayload
    "Deletes a card"
    deleteCard(input: DeleteCardInput!): DeleteCardPayload
    "Deletes a comment"
    deleteComment(input: DeleteCommentInput!): DeleteCommentPayload
    "Deletes a field condition"
    deleteFieldCondition(input: DeleteFieldConditionInput!): DeleteFieldConditionPayload @deprecated(reason: "Mutation will be removed in the next update")
    "Deletes an email"
    deleteInboxEmail(input: DeleteInboxEmailInput!): DeleteInboxEmailPayload
    "Deletes a label"
    deleteLabel(input: DeleteLabelInput!): DeleteLabelPayload
    "Deletes an organization"
    deleteOrganization(input: DeleteOrganizationInput!): DeleteOrganizationPayload
    "Deletes a webhook"
    deleteOrganizationWebhook(input: DeleteOrganizationWebhookGQLMutationInput!): DeleteOrganizationWebhookGQLMutationPayload
    "Deletes a phase"
    deletePhase(input: DeletePhaseInput!): DeletePhasePayload
    "Deletes a phase field"
    deletePhaseField(input: DeletePhaseFieldInput!): DeletePhaseFieldPayload
    "Deletes a pipe"
    deletePipe(input: DeletePipeInput!): DeletePipePayload
    "Deletes a pipe relation"
    deletePipeRelation(input: DeletePipeRelationInput!): DeletePipeRelationPayload
    "Deletes a table"
    deleteTable(input: DeleteTableInput!): DeleteTablePayload
    "Deletes a table field"
    deleteTableField(input: DeleteTableFieldInput!): DeleteTableFieldPayload
    "Deletes a record"
    deleteTableRecord(input: DeleteTableRecordInput!): DeleteTableRecordPayload
    "Deletes a table relation"
    deleteTableRelation(input: DeleteTableRelationInput!): DeleteTableRelationPayload @deprecated(reason: "Mutation will be removed in the next update")
    "Deletes a webhook (pipe or table level)"
    deleteWebhook(input: DeleteWebhookInput!): DeleteWebhookPayload
    "Exports a pipe report"
    exportPipeReport(input: ExportPipeReportInput!): ExportPipeReportPayload
    "Invites new members for the organization"
    inviteMembers(input: InviteMembersInput!): InviteMembersPayload
    "Moves a card to another phase"
    moveCardToPhase(input: MoveCardToPhaseInput!): MoveCardToPhasePayload
    "Create new records from a xlsx file"
    recordsImporter(input: RecordsImporterInput!): RecordsImporterPayload
    "Remove a user from an organization"
    removeUserFromOrg(input: RemoveUserFromOrgInput!): RemoveUserFromOrgPayload
    "Removes a user from pipe"
    removeUserFromPipe(input: RemoveUserFromPipeInput!): RemoveUserFromPipePayload
    "Removes an user from table"
    removeUserFromTable(input: RemoveUserFromTableInput!): RemoveUserFromTablePayload
    "Sends an email"
    sendInboxEmail(input: SendInboxEmailInput!): SendInboxEmailPayload
    setDismissedImprovement(input: SetDismissedImprovementInput!): SetDismissedImprovementPayload @deprecated(reason: "Mutation will be removed in the next update")
    "Sets field condition order"
    setFieldConditionOrder(input: setFieldConditionOrderInput!): setFieldConditionOrderPayload @deprecated(reason: "Mutation will be removed in the next update")
    setImprovementAsRead(input: SetImprovementAsReadInput!): SetImprovementAsReadPayload @deprecated(reason: "Mutation will be removed in the next update")
    "Sets the role of a user"
    setRole(input: SetRoleInput!): SetRolePayload
    "Sets role of multiple users"
    setRoles(input: SetRolesInput!): SetRolesPayload
    "Sets summary attributes"
    setSummaryAttributes(input: SetSummaryAttributesInput!): SetSummaryAttributesPayload
    "Sets table field order"
    setTableFieldOrder(input: SetTableFieldOrderInput!): SetTableFieldOrderPayload
    "Sets record field value"
    setTableRecordFieldValue(input: SetTableRecordFieldValueInput!): SetTableRecordFieldValuePayload
    "Updates an existing card"
    updateCard(input: UpdateCardInput!): UpdateCardPayload
    "Updates an existing card field"
    updateCardField(input: UpdateCardFieldInput!): UpdateCardFieldPayload
    "Updates an existing comment"
    updateComment(input: UpdateCommentInput!): UpdateCommentPayload
    "Updates an existing field condition"
    updateFieldCondition(input: UpdateFieldConditionInput!): UpdateFieldConditionPayload @deprecated(reason: "Mutation will be removed in the next update")
    "Update one or many values of fields inside a Card or Table record."
    updateFieldsValues(input: UpdateFieldsValuesInput!): UpdateFieldsValuesPayload
    "Updates an existing label"
    updateLabel(input: UpdateLabelInput!): UpdateLabelPayload
    "Updates an existing organization"
    updateOrganization(input: UpdateOrganizationInput!): UpdateOrganizationPayload
    "Updates an existing organization-level webhook"
    updateOrganizationWebhook(input: UpdateOrganizationWebhookInput!): UpdateOrganizationWebhookPayload
    "Updates an existing phase"
    updatePhase(input: UpdatePhaseInput!): UpdatePhasePayload
    "Updates an existing phase field"
    updatePhaseField(input: UpdatePhaseFieldInput!): UpdatePhaseFieldPayload
    "Updates an existing pipe"
    updatePipe(input: UpdatePipeInput!): UpdatePipePayload
    "Updates an existing pipe relation"
    updatePipeRelation(input: UpdatePipeRelationInput!): UpdatePipeRelationPayload
    "Updates an existing table"
    updateTable(input: UpdateTableInput!): UpdateTablePayload
    "Updates an existing table field"
    updateTableField(input: UpdateTableFieldInput!): UpdateTableFieldPayload
    "Updates an existing record"
    updateTableRecord(input: UpdateTableRecordInput!): UpdateTableRecordPayload
    "Updates an existing table relation"
    updateTableRelation(input: UpdateTableRelationInput!): UpdateTableRelationPayload @deprecated(reason: "Mutation will be removed in the next update")
    "Updates an existing webhook (pipe or table level)"
    updateWebhook(input: UpdateWebhookInput!): UpdateWebhookPayload
}

"The number field"
type NumberField implements FieldType {
    "The field description"
    description: String
    "The field current state"
    displayState(
        "Array with current field value information"
        currentFieldValues: [FilledField],
        "User persisted card values on conditional"
        useCardValues: Boolean
    ): ConditionFieldActions
    "The field help text"
    helpText: String
    "The field ID"
    id: ID! @deprecated(reason: "Please, use uuid")
    "Number field initial value"
    initialValue(
        "Array with initial value information"
        initialValues: [FilledField]
    ): Float
    "If the field could be editable"
    isEditable(
        "Slug ID used to share a card on a phase"
        phaseFormId: ID!
    ): Boolean
    "Whether the field is required"
    isRequired: Boolean
    "The field title"
    label: String!
    "Whether the field is minimal"
    minimalView: Boolean
    "Whether the field triggers a condition"
    triggersFieldConditions: Boolean
    "The field type. Valid options: assignee_select, attachment, checklist_horizontal, checklist_vertical, cnpj, connector, cpf, currency, date, datetime, due_date, email, id, label_select, long_text, number, phone, radio_horizontal, radio_vertical, select, short_text, statement, time,dynamic_content"
    type: String
    "Whether the field value must be unique"
    unique: Boolean
    "The field universally unique ID"
    uuid: ID!
}

"List of organization information"
type Organization implements OrganizationInterface {
    "Organization billing infos"
    billing: Billing
    "When the organization was created"
    createdAt: DateTime!
    "User that created the organization"
    createdBy: User
    "When the organization was created"
    created_at: DateTime! @deprecated(reason: "This field is deprecated.\n    Use `createdAt` instead.")
    "The organization logo URL"
    customLogoUrl: String
    "The organization logo URL"
    custom_logo_url: String @deprecated(reason: "This field is deprecated.\n    Use `customLogoUrl` instead.")
    freemium: Boolean
    "The organization ID"
    id: ID!
    "Information about the organization members"
    members(limit: Int): [Member]
    "Quantity of members of the organization"
    membersCount: Int
    "Quantity of members of the organization by role"
    membersCountByRole: [Role]
    "The organization name"
    name: String
    "Whether only Admins can create pipes"
    onlyAdminCanCreatePipes: Boolean
    "Whether only Admins can invite new users"
    onlyAdminCanInviteUsers: Boolean
    "Whether only Admins can create pipes"
    only_admin_can_create_pipes: Boolean @deprecated(reason: "This field is deprecated.\n    Use `onlyAdminCanCreatePipes` instead.")
    "Whether only Admins can invite new users"
    only_admin_can_invite_users: Boolean @deprecated(reason: "This field is deprecated.\n    Use `onlyAdminCanInviteUsers` instead.")
    "User permissions for this org"
    permissions: OrganizationPermissionsInternalGQLType
    "Fetches a group of pipes based on arguments"
    pipes(
        anyone_can_create_card: Boolean,
        ids: [ID],
        include_publics: Boolean,
        "The pipes search query"
        name_search: String,
        onlyFullyVisible: Boolean,
        with_permission: String
    ): [Pipe]
    "Quantity of pipes of the organization"
    pipesCount: Int
    planName: String
    "Current user's role in the organization"
    role: String
    "Fetches a group of database tables based on arguments"
    tables(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "The tables search query"
        name_search: String
    ): TableConnection
    "Info on user metadata related to the current organization"
    userMetadata: OrganizationUserMetadata
    "Information about the organization users"
    users(limit: Int): [User]
    "Quantity of members of the organization"
    users_count: Int @deprecated(reason: "This field is deprecated.\n    Use `membersCount` instead.")
    "The organization UUID"
    uuid: ID!
    "Information about the organization Webhooks"
    webhooks: [Webhook]
}

"Org permissions for the given user"
type OrganizationPermissionsInternalGQLType {
    canManageCustomRoles: Boolean
    inviteMember: Boolean!
    showAdminPortal: Boolean!
    showCompanyActivities: Boolean!
    showCompanyReports: Boolean!
    showCreateDatabases: Boolean
    showCreatePipeBanner: Boolean!
    showDashboard: Boolean!
    showDashboardMobile: Boolean!
    showInviteMember: Boolean!
    showMyTasks: Boolean!
    showPortals: Boolean!
    showRepoList: Boolean!
}

"Info on user metadata related to the current organization"
type OrganizationUserMetadata {
    "Whether the user can create a new pipe"
    canCreatePipe: Boolean!
    "Whether the user can invite another user to this organization or not"
    canInviteUser: Boolean!
}

"Information about pagination in a connection."
type PageInfo {
    "When paginating forwards, the cursor to continue."
    endCursor: String
    "When paginating forwards, are there more items?"
    hasNextPage: Boolean!
    "When paginating backwards, are there more items?"
    hasPreviousPage: Boolean!
    "When paginating backwards, the cursor to continue."
    startCursor: String
}

"List of phase information"
type Phase implements MinimalPhaseInterface {
    "Phase can receive cards directly from draft?"
    can_receive_card_directly_from_draft: Boolean
    "Fetches a group of cards based on arguments"
    cards(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        search: CardSearch
    ): CardConnection
    "Information about the phases that the cards can be moved to"
    cards_can_be_moved_to_phases: [Phase]
    "The phase total cards"
    cards_count(filter: RepoItemFilter): Int
    "Color of phase"
    color: String
    "When the phase was created"
    created_at: DateTime
    "Custom sorting preferences"
    custom_sorting_preferences: JSON
    "The phase description"
    description: String
    "Whether it is a final phase"
    done: Boolean!
    "The phase total expired cards"
    expiredCardsCount(filter: RepoItemFilter): Int
    "Information about the phase field conditions"
    fieldConditions: [FieldCondition]
    "Information about the fields"
    fields: [PhaseField]
    "The phase ID"
    id: ID!
    "The phase positional index"
    index: Float
    "Is this phase draft?"
    isDraft: Boolean
    "The phase total late cards"
    lateCardsCount(filter: RepoItemFilter): Int
    "Lateness time"
    lateness_time: Int
    "The phase name"
    name: String!
    "Information about the next phases the cards can be moved to"
    next_phase_ids: [Int]
    "Information about the previous phases that the cards can be moved to"
    previous_phase_ids: [Int]
    "Phase repo ID"
    repo_id: Int
    "The sequential identifier"
    sequentialId: String
    "The phase universally unique ID"
    uuid: ID!
}

"List of the phase history information."
type PhaseDetail {
    "Whether or not the card ever became late on a phase."
    became_late: Boolean
    "Represents the date and time of when the card first entered the phase."
    created_at: DateTime
    "Whether or not the phase detail is in the start form."
    draft: Boolean
    "Represents the seconds card stayed in the phase."
    duration: Int
    "Represents the date and time of when card first entered the phase."
    firstTimeIn: DateTime
    "Represents the date and time of when card last entered the phase."
    lastTimeIn: DateTime
    "Represents the date and time of when card left the phase."
    lastTimeOut: DateTime
    "Lookup the phase by its identifier."
    phase: Phase
}

"List of field information"
type PhaseField implements GenericField & MinimalFieldInterface {
    "Whether all child items must be done to finish the parent item"
    allChildrenMustBeDoneToFinishParent: Boolean
    "Whether all child items must be done to move the parent item"
    allChildrenMustBeDoneToMoveParent: Boolean
    "Whether it's possible to connect existing items"
    canConnectExisting: Boolean
    "Whether it's possible to connect multiple items"
    canConnectMultiples: Boolean
    "Whether its possible to create new connected items"
    canCreateNewConnected: Boolean
    "Whether a child must exist to finish the parent"
    childMustExistToFinishParent: Boolean
    "Repo (Pipe or Table) representation"
    connectedRepo: PublicRepoUnion
    "Repo (Pipe or Table) representation"
    connected_repo: RepoTypes @deprecated(reason: "connected_repo has been replaced by connectedRepo")
    "The regex used to validate the field value"
    custom_validation: String
    "The field description"
    description: String
    "Whether the field is editable in future phases"
    editable: Boolean
    "The field help text"
    help: String
    "The field ID"
    id: ID!
    "field index"
    index: Float
    "field index name"
    index_name: String
    "The field internal ID"
    internal_id: ID!
    "Whether the field accepts multiple entries"
    is_multiple: Boolean
    "The field title"
    label: String
    "Whether the field is minimal"
    minimal_view: Boolean
    "The options of the Checklist, Radio or Select field"
    options: [String]
    "Information about the phase"
    phase: Phase
    "Whether the field is required"
    required: Boolean
    "Whether the phase field is synchronized with the fix field"
    synced_with_card: Boolean
    "The field type. Valid options: assignee_select, attachment, checklist_horizontal, checklist_vertical, cnpj, connector, cpf, currency, date, datetime, due_date, email, id, label_select, long_text, number, phone, radio_horizontal, radio_vertical, select, short_text, statement, time, formula, dynamic_content"
    type: String
    "The field Universally Unique ID"
    uuid: ID!
}

"The connection type for PhaseField."
type PhaseFieldConnection {
    "A list of edges."
    edges: [PhaseFieldEdge]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type PhaseFieldEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: PhaseField
}

"The phone field"
type PhoneField implements FieldType {
    "The field description"
    description: String
    "The field current state"
    displayState(
        "Array with current field value information"
        currentFieldValues: [FilledField],
        "User persisted card values on conditional"
        useCardValues: Boolean
    ): ConditionFieldActions
    "The field help text"
    helpText: String
    "The field ID"
    id: ID! @deprecated(reason: "Please, use uuid")
    "Phone field initial value"
    initialValue(
        "Array with initial value information"
        initialValues: [FilledField]
    ): String
    "If the field could be editable"
    isEditable(
        "Slug ID used to share a card on a phase"
        phaseFormId: ID!
    ): Boolean
    "Whether the field is required"
    isRequired: Boolean
    "The field title"
    label: String!
    "Whether the field is minimal"
    minimalView: Boolean
    "Whether the field triggers a condition"
    triggersFieldConditions: Boolean
    "The field type. Valid options: assignee_select, attachment, checklist_horizontal, checklist_vertical, cnpj, connector, cpf, currency, date, datetime, due_date, email, id, label_select, long_text, number, phone, radio_horizontal, radio_vertical, select, short_text, statement, time,dynamic_content"
    type: String
    "Whether the field value must be unique"
    unique: Boolean
    "The field universally unique ID"
    uuid: ID!
}

"List of pipe information"
type Pipe implements PipeSharedProperties & PublicPipeInterface & Repo {
    "Whether anyone can create cards in the pipe"
    anyone_can_create_card: Boolean
    "The pipe total cards"
    cards_count: Int
    "Information about the pipe child connections"
    childrenRelations(
        "Return only table relations"
        only_tables: Boolean
    ): [PipeRelation]
    "Id which the Pipe was cloned from"
    clone_from_id: Int
    "Color of pipe/database"
    color: String
    "IDs of all fields in a pipe that trigger conditionals"
    conditionExpressionsFieldIds: [Int]
    "The content displayed in the start form button"
    create_card_label: String
    "When the pipe was created"
    created_at: DateTime
    "The Repo description"
    description: String
    "The pipe's email inbox address"
    emailAddress: String
    "The number used in the pipe SLA"
    expiration_time_by_unit: Int
    "The seconds of the unit used in the pipe SLA"
    expiration_unit: Int
    "Information about the fields conditions"
    fieldConditions: [FieldCondition]
    "The Repo icon"
    icon: String
    "The pipe ID"
    id: ID!
    "Information about the pipe improvement setting"
    improvementSetting: ImprovementSetting
    "Information about the Repo labels"
    labels: [Label]
    "When a card was last updated in the pipe"
    last_updated_by_card: DateTime
    "Information about the Repo members"
    members(limit: Int): [Member]
    "The Repo name"
    name: String!
    "The Repo noun for their registries"
    noun: String!
    "Whether only Admins can delete cards"
    only_admin_can_remove_cards: Boolean
    "Whether only the card assignees can edit it"
    only_assignees_can_edit_cards: Boolean
    "The total amount of cards not done"
    opened_cards_count: Int
    "Information about the organization"
    organization: Organization
    "Card organization id"
    organizationId: ID!
    "Information about the pipe parent connections"
    parentsRelations: [PipeRelation]
    "User permissions for this repo"
    permissions: RepoPermissionsInternalGQLType
    "Information about the pipe phases"
    phases: [Phase]
    "Information about the pipe preferences"
    preferences: RepoPreference
    "Whether the Repo is public"
    public: Boolean
    "Information about the public form settings"
    publicForm: PublicFormInternal
    "Information about the public form settings"
    publicFormSettings: PublicFormSettings @deprecated(reason: "This field is deprecated. Use `publicForm` instead.")
    "Whether the public form is active"
    public_form: Boolean @deprecated(reason: "This field is deprecated. Use `publicForm { active }` instead.")
    "Whether the public form is active"
    public_form_active: Boolean @deprecated(reason: "This field is deprecated. Use `publicForm { active }` instead.")
    "The pipe's reports"
    reports: [PipeReport]
    "The current user role in the pipe"
    role: String
    "Information about the start form fields conditions"
    startFormFieldConditions: [FieldCondition]
    "The repo start form phase id"
    startFormPhaseId: ID
    "Information about the start form fields"
    start_form_fields: [PhaseField]
    "Fields used that is set as subtitle"
    subtitleFields(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int
    ): PhaseFieldConnection
    "The pipe Small Unique ID"
    suid: String
    "Information about the data selected to be shown in the summarized view"
    summary_attributes: [SummaryAttribute]
    "Information about the Repo summary options"
    summary_options: [SummaryGroup]
    "Information about the field selected to be the card title"
    title_field: PhaseField
    "Information about the pipe users"
    users(filterUnacceptedInvitation: Boolean): [User]
    "The total users in the pipe"
    users_count: Int
    "Unique identifier id"
    uuid: String
    "Information about the pipe Webhooks"
    webhooks: [Webhook]
}

"List of the pipe's relation information."
type PipeRelation implements RepoConnection {
    "Whether all children must be done to finish the parent"
    allChildrenMustBeDoneToFinishParent: Boolean
    "Whether all children must be done to move the parent"
    allChildrenMustBeDoneToMoveParent: Boolean
    "Whether or not the auto fill is enabled in the relation."
    autoFillFieldEnabled: Boolean
    "Whether its possible to connect existing items"
    canConnectExistingItems: Boolean
    "Whether its possible to connect multiple items"
    canConnectMultipleItems: Boolean
    "Whether its possible to create new connected items"
    canCreateNewItems: Boolean
    "Information about the child Repo"
    child: RepoTypes
    "Whether a child must exist to finish the parent"
    childMustExistToFinishParent: Boolean
    "Whether a child must exist to move the parent"
    childMustExistToMoveParent: Boolean
    "The relation ID"
    id: ID!
    "The relation name"
    name: String!
    "Represents a map of fields of a parent-item to auto fill fields of a child-item's start form."
    ownFieldMaps: [FieldMap]
    "Information about the parent Repo"
    parent: RepoTypes
}

"Lookup a organization report by its ID"
type PipeReport {
    "How many cards are returned in the report"
    cardCount: Int!
    "Color of report"
    color: String
    "When the report was created"
    createdAt: DateTime
    "Featured formula that summarizes the Report "
    featuredField: String
    "Fields to show in the report"
    fields: [String]
    "Filter to report"
    filter: Json
    "The report identifier"
    id: ID!
    "When the report was last updated"
    lastUpdatedAt: DateTime
    "When the exportation took place"
    name: String
    "Formula fields selected for the report"
    selectedFormulaFields: [PipeReportFormulaField]
    "How cards are sorted in the report."
    sortBy: ReportSortDirection
}

"Lookup a organization report export by its ID"
type PipeReportExport {
    "The location of the exported file"
    fileURL: String
    "When the exportation finished executing"
    finishedAt: DateTime
    "The report export identifier"
    id: ID!
    "The user who requested the exportation"
    report: PipeReport
    "The user who requested the exportation"
    requestedBy: User!
    "When the exportation took place"
    startedAt: DateTime
    "The exportation current state"
    state: ExportationState!
}

type PipeReportFormulaField {
    "formula field average value"
    avg: Float
    "formula field count value"
    count: Float
    "formula field index name"
    indexName: String
    "The field title"
    label: String
    "formula field max value"
    max: Float
    "formula field min value"
    min: Float
    "formula field selected formula"
    selectedFormula: String
    "formula field sum value"
    sum: Float
}

"List of the pipe templates information."
type PipeTemplate {
    "Represents the name of the icon selected to represent the template."
    icon: String
    "Represents the template identifier."
    id: String
    "Represents the name of the image selected to represent the template."
    image: String
    "Represents the template name."
    name: String
}

"PlatformApps used in the Repo"
type PlatformApp {
    "The attachments of the app for a given card"
    attachments_connection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "The card ID"
        cardId: ID!,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int
    ): AppAttachmentConnection
    id: ID
    name: String
    public: Boolean
    slug: String
    url: String
}

"Card information"
type PublicCard implements PublicRepoItemInterface {
    "When the record was created"
    created_at: DateTime
    "Information about icon name and color"
    icon: Icon
    "The item ID"
    id: ID!
    "The item path"
    path: String
    "The record status"
    status: TableRecordStatus
    "The item summary layout information"
    summary: [Summary]
    "Information about the repo item attributes summary layout"
    summary_attributes: [Summary]
    "Information about the repo item custom fields summary layout"
    summary_fields: [Summary]
    "The item title"
    title: String!
    "The URL"
    url: String!
    "The item uuid"
    uuid: ID!
}

"Public form fields used in the internal API"
type PublicFormInternal implements PublicFormInterface {
    "Public Form is active or not"
    active: Boolean
    "The message shown to user after submitting the public form"
    afterSubmitMessage: String
    "The background color of the public form (RGB)"
    backgroundColor: String
    "The background image URL of the public form"
    backgroundImage: String
    "The brand color that will be used in the public form (RGB)"
    brandColor: String
    "Whether the public form creator can hide Pipefy's logo"
    canHidePipefyLogo: Boolean
    "Description of the public form"
    description: String
    "Whether to display Pipefy's logo in the public form"
    displayPipefyLogo: Boolean
    id: ID!
    "Logo of the public form"
    logo: String
    "The name of the organization to be shown in the public form"
    organizationName: String
    "Fill again with the same values that were used on the last submission"
    reuseLastSubmissionResponse: Boolean
    "Whether its allowed to submit another response"
    showSubmitAnotherResponseButton: Boolean
    "Text of the submit button on the public form"
    submitButtonText: String
    "Whether the submitter email collection is enabled"
    submitterEmailCollectionEnabled: Boolean
    "The method to ask for the submitter email in the public form"
    submitterEmailCollectionMethod: PublicFormSubmitterEmailCollectionMethod
    submitterEmailField: MinimalField
    "Title of the public form"
    title: String
    "Public form URL"
    url: String
}

"Public form fields"
type PublicFormSettings implements PublicFormInterface {
    "The message shown to user after submitting the public form"
    afterSubmitMessage: String
    "The background color of the public form (RGB)"
    backgroundColor: String
    "The background image URL of the public form"
    backgroundImage: String
    "The brand color that will be used in the public form (RGB)"
    brandColor: String
    "Whether the public form creator can hide Pipefy's logo"
    canHidePipefyLogo: Boolean
    "Public Form hCaptcha enablement flag"
    captchaEnabled: Boolean
    "Description of the public form"
    description: String
    "Whether to display Pipefy's logo in the public form"
    displayPipefyLogo: Boolean
    id: ID!
    "Logo of the public form"
    logo: String
    "The name of the organization to be shown in the public form"
    organizationName: String
    "Public form URL"
    public_url: String
    "Fill again with the same values that were used on the last submission"
    reuseLastSubmissionResponse: Boolean
    "Whether its allowed to submit another response"
    showSubmitAnotherResponseButton: Boolean
    "Text of the submit button on the public form"
    submitButtonText: String
    "Whether the submitter email collection is enabled"
    submitterEmailCollectionEnabled: Boolean
    "The method to ask for the submitter email in the public form"
    submitterEmailCollectionMethod: PublicFormSubmitterEmailCollectionMethod
    submitterEmailField: MinimalField
    "Title of the public form"
    title: String
}

type PublicPhaseFormLink {
    active: Boolean!
    url: String
}

"Pipe information"
type PublicPipe implements PublicRepoGQLInterface {
    "The creation button label"
    createButtonLabel: String
    "The Repo icon"
    icon: String
    "The pipe ID"
    id: ID!
    "The Repo name"
    name: String!
    "The Repo UUID"
    uuid: ID!
}

"Repo item information"
type PublicRepoItem implements PublicRepoItemInterface {
    "When the record was created"
    created_at: DateTime
    "Information about icon name and color"
    icon: Icon
    "The item ID"
    id: ID!
    "The item path"
    path: String
    "The record status"
    status: TableRecordStatus
    "The item summary layout information"
    summary: [Summary]
    "Information about the repo item attributes summary layout"
    summary_attributes: [Summary]
    "Information about the repo item custom fields summary layout"
    summary_fields: [Summary]
    "The item title"
    title: String!
    "The URL"
    url: String!
    "The item uuid"
    uuid: ID!
}

"Table information"
type PublicTable implements PublicRepoGQLInterface {
    "Color of database"
    color: String
    "The creation button label"
    createButtonLabel: String
    "The Repo icon"
    icon: String
    "The table ID"
    id: ID!
    "The internal table ID"
    internal_id: ID!
    "The Repo name"
    name: String!
    "The Repo UUID"
    uuid: ID!
}

"Record information"
type PublicTableRecord implements PublicRepoItemInterface {
    "When the record was created"
    created_at: DateTime
    "Information about icon name and color"
    icon: Icon
    "The item ID"
    id: ID!
    "The item path"
    path: String
    "The record status"
    status: TableRecordStatus
    "The item summary layout information"
    summary: [Summary]
    "Information about the repo item attributes summary layout"
    summary_attributes: [Summary]
    "Information about the repo item custom fields summary layout"
    summary_fields: [Summary]
    "The item title"
    title: String!
    "The URL"
    url: String!
    "The item uuid"
    uuid: ID!
}

"The connection type for PublicTableRecord."
type PublicTableRecordConnection {
    "A list of edges."
    edges: [PublicTableRecordEdge]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type PublicTableRecordEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: PublicTableRecord
}

"User information"
type PublicUser {
    "The user's avatar URL"
    avatarUrl: String
    "The user's avatar URL"
    avatar_url: String @deprecated(reason: "Use the camelCase variant (`avatarUrl`)")
    "The user email"
    email: String
    "The user ID"
    id: ID!
    "The user name"
    name: String
    "The user username"
    username: String!
}

"The query root of Pipefy's GraphQL interface"
type Query {
    "Fetches all pipe cards based on arguments"
    allCards(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Search filter"
        filter: AdvancedSearch,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "The pipe ID"
        pipeId: ID!
    ): CardConnection
    "Lookup the values that will automatically fill the child-card's start form fields"
    autoFillFields(connectorId: ID!, connectorType: String!, overrideFieldValue: [FilledField], parentCardId: ID!): [AutoFillFieldUnion]
    "Lookup a card by its ID"
    card(
        "The card ID"
        id: ID!
    ): Card
    "Fetches a group of cards based on arguments"
    cards(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "The pipe ID"
        pipe_id: ID!,
        "Arguments that can be used to filter the search"
        search: CardSearch
    ): CardConnection
    "Lookup the cards importer history by the pipe ID"
    cardsImportations(
        "The pipe ID"
        pipeId: ID!,
        "Filter importation by status, which can be either \"enqueued\", \"importing\", \"failed\" or \"imported\" "
        status: [String]
    ): [CardsImportation]
    conditionalField(cardId: ID, overrideFieldValue: [FilledField], repoId: ID!): ConditionalField
    connectedTableRecords(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        search: TableRecordSearch,
        tableId: ID!,
        throughConnectors: ReferenceConnectorFieldInput!
    ): PublicTableRecordConnection
    fieldCondition(id: ID!): FieldCondition
    "Fetch cards based on fields' inputs"
    findCards(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "The pipe ID"
        pipeId: ID!,
        "Arguments to be used to find cards"
        search: FindCards!
    ): CardConnection
    "Fetch records based on fields' inputs"
    findRecords(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Arguments to be used to find cards"
        search: FindCards!,
        "The table ID"
        tableId: String!
    ): CardConnection
    "Lookup the card's emails by its ID"
    inbox_emails(
        "The card ID"
        card_id: ID!
    ): [InboxEmail]
    "Returns informations of the current authenticated user"
    me: User
    "Lookup an organization by its ID"
    organization(
        "The organization ID"
        id: ID!
    ): Organization
    "Lookup organizations by their ID"
    organizations(
        "The organizations IDs"
        ids: [ID],
        "Order by organizations names"
        order: Boolean
    ): [Organization]
    "Lookup a phase by its ID"
    phase(
        "The phase ID"
        id: ID!
    ): Phase
    "Lookup a pipe by its ID"
    pipe(
        "The pipe ID"
        id: ID!
    ): Pipe
    "Lookup a pipe report export by its ID"
    pipeReportExport(
        "The export ID"
        id: ID!
    ): PipeReportExport
    "Lookup pipe relations by their ID"
    pipe_relations(
        "The pipe relation ID"
        ids: [ID]!
    ): [PipeRelation]
    "Lookup all pipe templates available on Pipefy"
    pipe_templates: [PipeTemplate]
    "Lookup pipes by their ID"
    pipes(
        "The pipes IDs"
        ids: [ID]!
    ): [Pipe]
    "Lookup the records importer history by the table ID"
    recordsImportations(
        "Filter importation by status"
        status: [String],
        "The table ID"
        tableId: ID!
    ): [RecordsImportation]
    repoItemForm(repoId: ID!, throughConnectors: ReferenceConnectorFieldInput): RepoItemFormUnion
    "Lookup a database table by its ID"
    table(
        "The table ID"
        id: ID!,
        throughConnectors: ReferenceConnectorFieldCoreInput
    ): Table
    "Lookup a record by its ID"
    table_record(
        "The record ID"
        id: ID!
    ): TableRecord
    "Fetches a group of records based on arguments"
    table_records(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Arguments that can be used to filter the search"
        search: TableRecordSearch,
        "The table ID"
        table_id: ID!
    ): TableRecordWithCountConnection
    "Lookup table relations by their ID"
    table_relations(
        "The table relation ID"
        ids: [ID]!
    ): [TableRelation]
    "Lookup database tables by their ID"
    tables(
        "The tables IDs"
        ids: [ID]!
    ): [Table]
}

"The horizontal radio field"
type RadioHorizontalField implements FieldType {
    "The field description"
    description: String
    "The field current state"
    displayState(
        "Array with current field value information"
        currentFieldValues: [FilledField],
        "User persisted card values on conditional"
        useCardValues: Boolean
    ): ConditionFieldActions
    "The field help text"
    helpText: String
    "The field ID"
    id: ID! @deprecated(reason: "Please, use uuid")
    "Horizontal radio field initial value"
    initialValue(
        "Array with initial value information"
        initialValues: [FilledField]
    ): String
    "If the field could be editable"
    isEditable(
        "Slug ID used to share a card on a phase"
        phaseFormId: ID!
    ): Boolean
    "Whether the field is required"
    isRequired: Boolean
    "The field title"
    label: String!
    "Whether the field is minimal"
    minimalView: Boolean
    "The horizontal radio options"
    options: [String]
    "Whether the field triggers a condition"
    triggersFieldConditions: Boolean
    "The field type. Valid options: assignee_select, attachment, checklist_horizontal, checklist_vertical, cnpj, connector, cpf, currency, date, datetime, due_date, email, id, label_select, long_text, number, phone, radio_horizontal, radio_vertical, select, short_text, statement, time,dynamic_content"
    type: String
    "The field universally unique ID"
    uuid: ID!
}

"The vertical radio field"
type RadioVerticalField implements FieldType {
    "The field description"
    description: String
    "The field current state"
    displayState(
        "Array with current field value information"
        currentFieldValues: [FilledField],
        "User persisted card values on conditional"
        useCardValues: Boolean
    ): ConditionFieldActions
    "The field help text"
    helpText: String
    "The field ID"
    id: ID! @deprecated(reason: "Please, use uuid")
    "Vertical radio field initial value"
    initialValue(
        "Array with initial value information"
        initialValues: [FilledField]
    ): String
    "If the field could be editable"
    isEditable(
        "Slug ID used to share a card on a phase"
        phaseFormId: ID!
    ): Boolean
    "Whether the field is required"
    isRequired: Boolean
    "The field title"
    label: String!
    "Whether the field is minimal"
    minimalView: Boolean
    "The vertical radio options"
    options: [String]
    "Whether the field triggers a condition"
    triggersFieldConditions: Boolean
    "The field type. Valid options: assignee_select, attachment, checklist_horizontal, checklist_vertical, cnpj, connector, cpf, currency, date, datetime, due_date, email, id, label_select, long_text, number, phone, radio_horizontal, radio_vertical, select, short_text, statement, time,dynamic_content"
    type: String
    "The field universally unique ID"
    uuid: ID!
}

"Records importer information"
type RecordsImportation implements RepoItemsImportationGQLInterface {
    "The importation date of creation"
    createdAt: DateTime
    "The importation creator"
    createdBy: User
    "The importation date of creation formatted"
    dateFormatted: String
    "The importation ID"
    id: ID!
    "The amount of records imported"
    importedRecords: Int
    "The importation status"
    status: String
    "The xlsx file URL"
    url: String
}

"Autogenerated return type of RecordsImporter"
type RecordsImporterPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Returns information about the importation"
    recordsImportation: RecordsImportation
}

"Autogenerated return type of RemoveUserFromOrg"
type RemoveUserFromOrgPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Whether the mutation was successful"
    success: Boolean
}

"Autogenerated return type of RemoveUserFromPipe"
type RemoveUserFromPipePayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Whether the mutation was successful"
    success: Boolean
}

"Autogenerated return type of RemoveUserFromTable"
type RemoveUserFromTablePayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Whether the mutation was successful"
    success: Boolean
}

"The connection type for RepoItemTypes."
type RepoItemTypesConnection {
    "A list of edges."
    edges: [RepoItemTypesEdge]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type RepoItemTypesEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: RepoItemTypes
}

"Repo permissions for the given user"
type RepoPermissionsInternalGQLType {
    configure_repo: Boolean!
    create_item: Boolean!
    delete_item: Boolean!
    delete_repo: Boolean!
    manage_field: Boolean!
    manage_label: Boolean!
    show_repo: Boolean!
}

"List of all settings/preferences regarding a Repo"
type RepoPreference {
    "External guests can or cannot create cards on this pipe"
    enableExternalGuests: Boolean
    "Represents the attributes selected to be hidden in the start form."
    hiddenStartFormAttributes: [String]
    "Represents the top buttons selected to be hidden in the open card."
    hiddenTopButtons: [String]
    "Whether or not the email client is enabled."
    inboxEmailEnabled: Boolean
    "Represents the views selected to be shown in the card."
    mainTabViews: [String]
    startFormTitle: String!
}

"Defines how the report results are to be sorted"
type ReportSortDirection {
    "The sort direction"
    direction: SortDirection!
    "The sort field"
    field: String!
}

"List of role information"
type Role {
    "Role created date"
    created_by: String
    "Role description"
    description: String
    "Role id"
    id: ID
    "If Role is custom"
    isCustom: Boolean
    "Number of users in this role"
    memberCount: Int
    "Role name"
    name: String
    "Role tile"
    title: String
    "Role last update"
    updated_by: String
    "Role UUID"
    uuid: ID
}

"The select field"
type SelectField implements FieldType {
    "The field description"
    description: String
    "The field current state"
    displayState(
        "Array with current field value information"
        currentFieldValues: [FilledField],
        "User persisted card values on conditional"
        useCardValues: Boolean
    ): ConditionFieldActions
    "The field help text"
    helpText: String
    "The field ID"
    id: ID! @deprecated(reason: "Please, use uuid")
    "Select field initial value"
    initialValue(
        "Array with initial value information"
        initialValues: [FilledField]
    ): String
    "If the field could be editable"
    isEditable(
        "Slug ID used to share a card on a phase"
        phaseFormId: ID!
    ): Boolean
    "Whether the field is required"
    isRequired: Boolean
    "The field title"
    label: String!
    "Whether the field is minimal"
    minimalView: Boolean
    "The select options"
    options: [String]
    "Whether the field triggers a condition"
    triggersFieldConditions: Boolean
    "The field type. Valid options: assignee_select, attachment, checklist_horizontal, checklist_vertical, cnpj, connector, cpf, currency, date, datetime, due_date, email, id, label_select, long_text, number, phone, radio_horizontal, radio_vertical, select, short_text, statement, time,dynamic_content"
    type: String
    "The field universally unique ID"
    uuid: ID!
}

"Autogenerated return type of SendInboxEmail"
type SendInboxEmailPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Whether the mutation was successful"
    success: Boolean
}

"Autogenerated return type of SetDismissedImprovement"
type SetDismissedImprovementPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    success: Boolean
}

"Autogenerated return type of SetImprovementAsRead"
type SetImprovementAsReadPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    success: Boolean
}

"Autogenerated return type of SetRole"
type SetRolePayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Returns information about the member"
    member: Member
}

"Autogenerated return type of SetRoles"
type SetRolesPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Returns possible errors in the mutation"
    errors: [String]
    "Returns information about the members"
    members: [Member]
}

"Autogenerated return type of SetSummaryAttributes"
type SetSummaryAttributesPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Returns information about the summary attributes"
    summary_attributes: [SummaryAttribute]
}

"Autogenerated return type of SetTableFieldOrder"
type SetTableFieldOrderPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Returns information about the table fields"
    table_fields: [TableField]
}

"Autogenerated return type of SetTableRecordFieldValue"
type SetTableRecordFieldValuePayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Returns information about the record"
    table_record: TableRecord
    "Returns information about the record field"
    table_record_field: TableRecordField
}

"The short text field"
type ShortTextField implements FieldType {
    "The short text field custom validation"
    customValidation: String
    "The field description"
    description: String
    "The field current state"
    displayState(
        "Array with current field value information"
        currentFieldValues: [FilledField],
        "User persisted card values on conditional"
        useCardValues: Boolean
    ): ConditionFieldActions
    "The field help text"
    helpText: String
    "The field ID"
    id: ID! @deprecated(reason: "Please, use uuid")
    "Short text field initial value"
    initialValue(
        "Array with initial value information"
        initialValues: [FilledField]
    ): String
    "If the field could be editable"
    isEditable(
        "Slug ID used to share a card on a phase"
        phaseFormId: ID!
    ): Boolean
    "Whether the field is required"
    isRequired: Boolean
    "The field title"
    label: String!
    "Whether the field is minimal"
    minimalView: Boolean
    "Whether the field triggers a condition"
    triggersFieldConditions: Boolean
    "The field type. Valid options: assignee_select, attachment, checklist_horizontal, checklist_vertical, cnpj, connector, cpf, currency, date, datetime, due_date, email, id, label_select, long_text, number, phone, radio_horizontal, radio_vertical, select, short_text, statement, time,dynamic_content"
    type: String
    "Whether the field value must be unique"
    unique: Boolean
    "The field universally unique ID"
    uuid: ID!
}

"The statement field"
type StatementField implements FieldType {
    "The field description"
    description: String
    "The field current state"
    displayState(
        "Array with current field value information"
        currentFieldValues: [FilledField],
        "User persisted card values on conditional"
        useCardValues: Boolean
    ): ConditionFieldActions
    "The field help text"
    helpText: String
    "The field ID"
    id: ID! @deprecated(reason: "Please, use uuid")
    "If the field could be editable"
    isEditable(
        "Slug ID used to share a card on a phase"
        phaseFormId: ID!
    ): Boolean
    "Whether the field is required"
    isRequired: Boolean
    "The field title"
    label: String!
    "Whether the field is minimal"
    minimalView: Boolean
    "Whether the field triggers a condition"
    triggersFieldConditions: Boolean
    "The field type. Valid options: assignee_select, attachment, checklist_horizontal, checklist_vertical, cnpj, connector, cpf, currency, date, datetime, due_date, email, id, label_select, long_text, number, phone, radio_horizontal, radio_vertical, select, short_text, statement, time,dynamic_content"
    type: String
    "The field universally unique ID"
    uuid: ID!
}

"List of the summary informations."
type Summary {
    "Represents the raw unformatted value of the selected field to be represented in the summary."
    raw_value: String!
    "Represents the title of the selected field to be represented in the summary."
    title: String!
    "Field type"
    type: String!
    "Represents the value of the selected field to be represented in the summary."
    value: String!
}

"List of the summary attributes information."
type SummaryAttribute {
    """

    Represents summary attribute identifier. It accepts the field's internal identifier or the repository attribute's slug.

    Valid repository attribute's options:
    - id
    - title
    - current_phase
    - labels
    - due_date
    - created_by
    - assignees
    - finished_at
    - created_at
    - status
    - updated_at
    - last_comment
    - last_comment_at
    """
    id: String!
}

"List of the summary group information."
type SummaryGroup {
    "Represents a general information of a card or a phase's field."
    name: String!
    "Lookup the summary group options by its identifier."
    options: [SummaryOption]
}

"List of the summary option information."
type SummaryOption {
    "Represents the field's internal identifier or the card attribute's slug."
    id: String!
    "Represents the summary option title label."
    label: String!
}

"List of table information"
type Table implements Repo {
    "Allows anyone to create cards"
    anyone_can_create_card: Boolean
    "Information about the database table authorization"
    authorization: TableAuthorization
    "Color of pipe/database"
    color: String
    "IDs of all fields in a pipe that trigger conditionals"
    conditionExpressionsFieldIds: [Int]
    "The content displayed in the start form button"
    create_record_button_label: String
    "The Repo description"
    description: String
    "The Repo icon"
    icon: String
    "The database table ID"
    id: ID!
    "The database table internal ID"
    internal_id: ID!
    "Information about the Repo labels"
    labels: [Label]
    "Information about the Repo members"
    members(limit: Int): [Member]
    "Information about the current user permission"
    my_permissions: TablePermission
    "The Repo name"
    name: String!
    "The Repo noun for their registries"
    noun: String!
    "The orderable fields. Valid options: title, status, created_at, updated_at, finished_at"
    orderableFields: [String]
    "The orderable field types"
    orderableTypes: [String]
    "Information about the organization"
    organization: Organization
    "User permissions for this repo"
    permissions: RepoPermissionsInternalGQLType
    "Whether the Repo is public"
    public: Boolean
    "Information about the public form settings"
    publicForm: PublicFormInternal
    "Information about the public form settings"
    publicFormSettings: PublicFormSettings @deprecated(reason: "This field is deprecated. Use `publicForm` instead.")
    "Whether the public form is active"
    public_form: Boolean @deprecated(reason: "This field is deprecated. Use `publicForm { active }` instead.")
    "Whether the public form is active"
    public_form_active: Boolean @deprecated(reason: "This field is deprecated. Use `publicForm { active }` instead.")
    "The repo start form phase id"
    startFormPhaseId: ID
    "Information about the database table statuses"
    statuses: [TableRecordStatus]
    "Information about the data selected to be shown in the summarized view"
    summary_attributes: [SummaryAttribute]
    "Information about the Repo summary options"
    summary_options: [SummaryGroup]
    "Information about the database table fields"
    table_fields: [TableField]
    "Fetches a group of records based on arguments"
    table_records(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int
    ): TableRecordConnection
    "The database table total records"
    table_records_count: Int
    "Information about the field selected to be the record title"
    title_field: TableField
    "The database table URL"
    url: String
    "The total users"
    users_count: Int
    "The database uuid"
    uuid: ID
    "Information about the table Webhooks"
    webhooks: [Webhook]
}

"The connection type for Table."
type TableConnection {
    "A list of edges."
    edges: [TableEdge]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type TableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Table
}

"List of table field information"
type TableField implements GenericField & MinimalFieldInterface {
    "Whether all child items must be done to finish the parent item"
    allChildrenMustBeDoneToFinishParent: Boolean
    "Whether it's possible to connect existing items"
    canConnectExisting: Boolean
    "Whether it's possible to connect multiple items"
    canConnectMultiples: Boolean
    "Whether its possible to create new connected items"
    canCreateNewConnected: Boolean
    "Whether a child must exist to finish the parent"
    childMustExistToFinishParent: Boolean
    "Repo (Pipe or Table) representation"
    connectedRepo: PublicRepoUnion
    "Repo (Pipe or Table) representation"
    connected_repo: RepoTypes @deprecated(reason: "connected_repo has been replaced by connectedRepo")
    "The regex used to validate the field value"
    custom_validation: String
    "The field description"
    description: String
    "The field help text"
    help: String
    "The field ID"
    id: ID!
    "field index"
    index: Float
    "field index name"
    index_name: String
    "The field internal ID"
    internal_id: ID!
    "Whether the field accepts multiple entries"
    is_multiple: Boolean
    "The field title"
    label: String
    "Whether the field is minimal"
    minimal_view: Boolean
    "The options of the Checklist, Radio or Select field"
    options: [String]
    "Whether the field is required"
    required: Boolean
    "The field type. Valid options: assignee_select, attachment, checklist_horizontal, checklist_vertical, cnpj, connector, cpf, currency, date, datetime, due_date, email, id, label_select, long_text, number, phone, radio_horizontal, radio_vertical, select, short_text, statement, time, formula, dynamic_content"
    type: String
    "Whether the field must have a unique value"
    unique: Boolean
    "The field Universally Unique ID"
    uuid: ID!
}

"List of the database table managing permissions."
type TablePermission {
    "Whether or not user can create, edit and delete records in the database table."
    can_manage_record: Boolean
    "Whether or not user can edit and delete the database table (Admin)."
    can_manage_table: Boolean
}

"List of table record information"
type TableRecord {
    "Information about the assign users"
    assignees: [User]
    "When the record was created"
    created_at: DateTime
    "Information about the record creator"
    created_by: User
    "Whether the record is done"
    done: Boolean
    "The record due date"
    due_date: DateTime
    "When the record was finished"
    finished_at: DateTime
    "The record ID"
    id: ID!
    "Informs if a record is a sample record"
    is_sample: Boolean
    "Information about the record labels"
    labels: [Label]
    "Information about the parent table connections"
    parent_relations(relation_name: String): [TableRecordRelation]
    "The record path"
    path: String
    "Information about the record fields"
    record_fields: [TableRecordField]
    "The record status"
    status: TableRecordStatus
    "Information about the record summary layout"
    summary: [Summary]
    "Information about the card attributes summary layout"
    summary_attributes: [Summary]
    "Information about the card custom fields summary layout"
    summary_fields: [Summary]
    "Information about the database table"
    table: Table
    "The record title"
    title: String
    "When the record was last updated"
    updated_at: DateTime
    "The URL"
    url: String!
    "The record uuid"
    uuid: ID!
}

"The connection type for TableRecord."
type TableRecordConnection {
    "A list of edges."
    edges: [TableRecordEdge]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type TableRecordEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: TableRecord
}

"Lookup all record fields information."
type TableRecordField implements MinimalCardFieldValueInterface & RepoItemFieldGQLInterface {
    "The value of an Attachment, Checklists, Connection or Label field, processed as an array type"
    array_value: [String]
    "Information about the users assigned to the card"
    assignee_values: [User]
    "Information about cards and records connected with the card"
    connectedRepoItems: [PublicRepoItemTypes]
    "Repo item (Card or Record) representation"
    connected_repo_items: [RepoItemTypes] @deprecated(reason: "Please, use connectedRepoItems")
    "The value of a Date, DateTime or DueDate field, processed as a date type"
    date_value: Date
    "The value of a DateTime or DueDate field, processed as a date and time type"
    datetime_value: DateTime
    "Information about the card field"
    field: MinimalField
    "When the field was filled"
    filled_at: DateTime
    "The field float value"
    float_value: Float
    "The searcheable name"
    indexName: String
    "Information about the card label"
    label_values: [FieldLabel]
    "The field name"
    name: String
    "The field value for show"
    native_value: String
    "Information about the field's phase"
    phase_field: PhaseField
    "The field value prepared for report"
    report_value: String
    "Whether or not the record's field is required."
    required: Boolean
    "When the field was last updated"
    updated_at: DateTime
    "The field value"
    value: String
}

"translation missing: en.api.documentation.table_record_form.description"
type TableRecordForm implements PublicRepoGQLInterface & RepoItemFormGQLInterface {
    "The creation button label"
    createButtonLabel: String
    "The available fields in Pipefy"
    formFields: [RepoItemFieldsTypes]
    "The Repo icon"
    icon: String
    id: ID!
    "The Repo name"
    name: String!
    "The Repo UUID"
    uuid: ID!
}

"List of the database table record's relations information."
type TableRecordRelation {
    "Represents a relation's id."
    id: ID
    "Represents a relation's name."
    name: String
    "Represents a repo (Card or Table Record)."
    repo: TableConnectedRepoGQLCoreUnionTypes
    "Fetches a group of records based on arguments."
    repo_items(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        done: Boolean,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int
    ): RepoItemTypesConnection
    "Represents the type source. It can be a database table or a pipe."
    source_type: String
}

"List of the record status information."
type TableRecordStatus {
    "Represents the status identifier."
    id: ID!
    "Represents the status name."
    name: String
}

"The connection type for TableRecord."
type TableRecordWithCountConnection {
    "A list of edges."
    edges: [TableRecordEdge]
    "The amount of records in the table"
    matchCount: Int
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"List of the table's relation information."
type TableRelation implements RepoConnection {
    "Whether all children must be done to finish the parent"
    allChildrenMustBeDoneToFinishParent: Boolean
    "Whether all children must be done to move the parent"
    allChildrenMustBeDoneToMoveParent: Boolean
    "Whether its possible to connect existing items"
    canConnectExistingItems: Boolean
    "Whether its possible to connect multiple items"
    canConnectMultipleItems: Boolean
    "Whether its possible to create new connected items"
    canCreateNewItems: Boolean
    "Information about the child Repo"
    child: RepoTypes
    "Whether a child must exist to finish the parent"
    childMustExistToFinishParent: Boolean
    "Whether a child must exist to move the parent"
    childMustExistToMoveParent: Boolean
    "The relation ID"
    id: ID!
    "The relation name"
    name: String!
    "Information about the parent Repo"
    parent: RepoTypes
}

"The time field"
type TimeField implements FieldType {
    "The field description"
    description: String
    "The field current state"
    displayState(
        "Array with current field value information"
        currentFieldValues: [FilledField],
        "User persisted card values on conditional"
        useCardValues: Boolean
    ): ConditionFieldActions
    "The field help text"
    helpText: String
    "The field ID"
    id: ID! @deprecated(reason: "Please, use uuid")
    "Time field initial value"
    initialValue(
        "Array with initial value information"
        initialValues: [FilledField]
    ): String
    "If the field could be editable"
    isEditable(
        "Slug ID used to share a card on a phase"
        phaseFormId: ID!
    ): Boolean
    "Whether the field is required"
    isRequired: Boolean
    "The field title"
    label: String!
    "Whether the field is minimal"
    minimalView: Boolean
    "Whether the field triggers a condition"
    triggersFieldConditions: Boolean
    "The field type. Valid options: assignee_select, attachment, checklist_horizontal, checklist_vertical, cnpj, connector, cpf, currency, date, datetime, due_date, email, id, label_select, long_text, number, phone, radio_horizontal, radio_vertical, select, short_text, statement, time,dynamic_content"
    type: String
    "Whether the field value must be unique"
    unique: Boolean
    "The field universally unique ID"
    uuid: ID!
}

"Autogenerated return type of UpdateCardField"
type UpdateCardFieldPayload {
    "Returns information about the card"
    card: Card
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Whether the mutation was successful"
    success: Boolean
}

"Autogenerated return type of UpdateCard"
type UpdateCardPayload {
    "Returns information about the card"
    card: Card
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
}

"Autogenerated return type of UpdateComment"
type UpdateCommentPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Returns information about the comment"
    comment: Comment
}

"Autogenerated return type of UpdateFieldCondition"
type UpdateFieldConditionPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Returns information about the fieldCondition"
    fieldCondition: FieldCondition
}

"Autogenerated return type of UpdateFieldsValues"
type UpdateFieldsValuesPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Return if the mutation ran succesfully or not."
    success: Boolean!
    "The updated card or table record."
    updatedNode: UpdatedNode
    "List of errors that occurred executing the mutation."
    userErrors: [UserError!]
}

"Autogenerated return type of UpdateLabel"
type UpdateLabelPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Returns information about the label"
    label: Label
}

"Autogenerated return type of UpdateOrganization"
type UpdateOrganizationPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Returns information about the organization"
    organization: Organization
}

"Autogenerated return type of UpdateOrganizationWebhook"
type UpdateOrganizationWebhookPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Returns information about the webhook"
    webhook: Webhook
}

"Autogenerated return type of UpdatePhaseField"
type UpdatePhaseFieldPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Returns information about the phase field"
    phase_field: PhaseField
}

"Autogenerated return type of UpdatePhase"
type UpdatePhasePayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Returns information about the phase"
    phase: Phase
}

"Autogenerated return type of UpdatePipe"
type UpdatePipePayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Returns information about the pipe"
    pipe: Pipe
}

"Autogenerated return type of UpdatePipeRelation"
type UpdatePipeRelationPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Returns information about the pipe relation"
    pipeRelation: PipeRelation
}

"Autogenerated return type of UpdateTableField"
type UpdateTableFieldPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Returns information about the table fields"
    table_field: TableField
}

"Autogenerated return type of UpdateTable"
type UpdateTablePayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Returns information about the table"
    table: Table
}

"Autogenerated return type of UpdateTableRecord"
type UpdateTableRecordPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Returns information about the record"
    table_record: TableRecord
}

"Autogenerated return type of UpdateTableRelation"
type UpdateTableRelationPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Returns information about the table relation"
    tableRelation: TableRelation
}

"Autogenerated return type of UpdateWebhook"
type UpdateWebhookPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Returns information about the webhook"
    webhook: Webhook
}

"List of user information"
type User implements UserInterface {
    "The user avatar URL"
    avatarUrl: String
    "The user avatar URL"
    avatar_url: String @deprecated(reason: "avatar_url has been replaced by avatarUrl")
    "Whether the user confirmation token expired and is no longer valid"
    confirmationTokenHasExpired: Boolean!
    "Whether the user is confirmed or not"
    confirmed: Boolean!
    "When the user was created"
    createdAt: String!
    "When the user was created"
    created_at: String! @deprecated(reason: "This field is deprecated. Use `createdAt` instead.")
    "The user department key"
    departmentKey: String
    "The user display name"
    displayName: String!
    "The user email"
    email: String!
    "Returns if the user has unread notifications"
    hasUnreadNotifications: Boolean
    "The user ID"
    id: ID!
    "Return the hash reference for intercom"
    intercomHash: String
    "The user intercom reference"
    intercomId: ID
    "Whether the user was invited to register or not"
    invited: Boolean!
    "The user language"
    locale: String
    "The user name"
    name: String
    "Current user permission to this user"
    permissions: UserPermissionsInternalGqlType
    "The user's phone"
    phone: String
    "The user preferences"
    preferences: UserPreference
    "The user template category key"
    signupData: String
    "The user time zone"
    timeZone: String @deprecated(reason: "This field is deprecated. Use `timezone` instead")
    "The user time zone"
    time_zone: String @deprecated(reason: "This field is deprecated. Use `timezone` instead")
    "The user time zone"
    timezone: String
    "The user username"
    username: String!
    "The user UUID"
    uuid: ID!
}

"Represents an error in the input of a mutation."
type UserError {
    "Path to the input field which caused the error."
    field: [String!]
    "The error message."
    message: String!
}

"User permissions based on current user session"
type UserPermissionsInternalGqlType {
    canChangeToCompanyGuestInAdminPortal: Boolean!
}

"List of user preferences information."
type UserPreference {
    "Whether the user notification is enable or not"
    browserNativeNotificationEnabled: Boolean
    "Whether the improvements are visible or not"
    displayImprovements: Boolean
    "Represents organization reports sidebar status (hide or show) of an user."
    displayOrganizationReportSidebar: Boolean
    "Whether the Pipe Reports Sidebar is visible or not"
    displayPipeReportsSidebar: Boolean
    "List of pipes (by id) favourited by the user"
    favoritePipeIds: [Int]
    "Whether the startform open in a modal or inside open card"
    openNestedStartForm: Boolean
    "Whether the sidebar is opened or not"
    sidebarOpened: Boolean
    "Whether the user closed the suggested templates box"
    suggestedTemplatesClosed: Boolean
}

"List of webhook information"
type Webhook {
    "The webhook triggers. Valid options: card.create, card.done, card.expired, card.late, card.move, card.overdue, card.field_update, card.delete, user.removal_from_org, user.removal_from_pipe, user.removal_from_table, user.role_set, user.invitation_acceptance, user.invitation_sent"
    actions: [String]
    "The webhook chosen email"
    email: String
    "The webhook custom headers in a valid JSON format. Example: {\"Custom-Header\": \"value\"}"
    headers: Json
    "The webhook ID"
    id: ID!
    "The webhook name"
    name: String
    "The webhook URL"
    url: String
}

type cardLateness {
    becameLateAt: DateTime
    id: ID!
    shouldBecomeLateAt: DateTime
    sla: Int!
}

"Autogenerated return type of createFieldCondition"
type createFieldConditionPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Returns information about the fieldCondition"
    fieldCondition: FieldCondition
}

"Autogenerated return type of setFieldConditionOrder"
type setFieldConditionOrderPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Returns information about the fieldCondition"
    fieldConditions: [FieldCondition]
}

"Advanced search valid operators"
enum AdvancedSearchOperators {
    "Equals to"
    equal
    "Greater than"
    gt
    "Greater than or equal to"
    gte
    "Less than"
    lt
    "Less than or equal to"
    lte
}

"Whether will get the union of the factors, or the intersection"
enum CardSearchStrategy {
    "Will get all cards containing all labels and all assignees id"
    intersection
    "Will get all cards containing, at least, one label and, at least, one assignee id"
    union
}

"Allowed colors on Pipefy"
enum Colors {
    "Blue color"
    blue
    "Cyan color"
    cyan
    "Gray color"
    gray
    "Green color"
    green
    "Indigo color"
    indigo
    "Lime color"
    lime
    "orange color"
    orange
    "Pink color"
    pink
    "Purple color"
    purple
    "Red color"
    red
    "Sky color"
    sky
    "Yellow color"
    yellow
}

"The condition field actions"
enum ConditionFieldActions {
    "Hide the field"
    hidden
}

"Exportation work state"
enum ExportationState {
    "Work is finished"
    done
    "Work failed"
    failed
    "Work is under process"
    processing
}

"Possible inbox email types"
enum InboxEmailType {
    "Email received"
    received
    "Email sent"
    sent
}

"The method of collecting the public form submitter email"
enum PublicFormSubmitterEmailCollectionMethod {
    "Collect email from an existing email field"
    from_existing_email_field
    "Show an optional email field"
    optional
    "Show a required email field"
    required
}

"Valid types for a field"
enum ReportCardsFilterFieldTypes {
    "Toggle"
    boolean
    "Date"
    date
    "Creator Email"
    email
    "Grouped Select"
    group_select
    "Number"
    number
    "Plain Select"
    select
    "String"
    string
}

"Valid operators for a locally scoped group of queries"
enum ReportCardsFilterGroupOperators {
    "All values must match"
    and
    "At least one value must match"
    or
}

"Valid operators for a filter query"
enum ReportCardsFilterQueryOperators {
    "Contains"
    contains
    "Equals"
    eq
    "Exists"
    exists
    "Greater than"
    gt
    "Greater or equal to"
    gte
    "Smaller than"
    lt
    "Smaller or equal to"
    lte
    "Not contains"
    not_contains
    "Not equals"
    not_eq
    "Not exists"
    not_exists
    "Period matching value"
    period
    "Unknown"
    unknown
}

"The direction of the sorting"
enum SortDirection {
    "Ascendant"
    asc
    "Descendant"
    desc
}

"The table authorization options"
enum TableAuthorization {
    "User can only view the records"
    read
    "User can add, edit and remove records"
    write
}

"Set the operation for the update field value."
enum UpdateFieldValuesOperators {
    "Append values to existing list of values, compatible with field types that support lists like Attachments, Assignees, Labels, Connections and Checklists."
    ADD
    "Remove values from the existing list of values, compatible with field types that support lists like Attachments, Assignees, Labels, Connections and Checklists."
    REMOVE
    "Replace the existing value with the new one provided."
    REPLACE
}

"An ISO8601 encoded UTC date string (YYYY-MM-DD)."
scalar Date

"An ISO8601 encoded UTC date time string (YYYY-MM-DD HH:MM:SS)."
scalar DateTime

"Represents untyped JSON"
scalar JSON

"A JSON (JavaScript Object Notation) format."
scalar Json

"A generic type."
scalar UndefinedInput

"Advanced search's inputs"
input AdvancedSearch {
    "Logical AND on all given filters"
    AND: [AdvancedSearch]
    "Logical OR on all given filters"
    OR: [AdvancedSearch]
    "The field slug"
    field: String
    "The search operator"
    operator: AdvancedSearchOperators
    "The field value"
    value: String
}

"Cards search's inputs"
input CardSearch {
    "The assignee ID"
    assignee_ids: [ID]
    "The cards ID to be ignored"
    ignore_ids: [ID]
    "3VL indicating whether theres an uread thread or not in the card"
    inbox_emails_read: Boolean
    "Shows or not done records"
    include_done: Boolean
    "The label ID"
    label_ids: [ID]
    "The strategy for searching list of ids (label and/or assignees). If nothing is selected, it will use union"
    search_strategy: CardSearchStrategy
    "The cards title"
    title: String
}

"Autogenerated input type of CardsImporter"
input CardsImporterInput {
    "The spreadsheet column with the card assignees email"
    assigneesColumn: String
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "The spreadsheet column with the card phase"
    currentPhaseColumn: String
    "The spreadsheet column with the card due date"
    dueDateColumn: String
    "Array with the field ID and its spreadsheet column with the value"
    fieldValuesColumns: [FieldValuesColumnsInput]
    "The spreadsheet column with the card label ID"
    labelsColumn: String
    "The pipe ID"
    pipeId: ID!
    "The xlsx file URL"
    url: String!
}

"Autogenerated input type of ClonePipes"
input ClonePipesInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "The organization ID"
    organization_id: ID
    "The pipe ID"
    pipe_template_ids: [ID]!
}

"Condition's expression inputs"
input ConditionExpressionInput {
    "The condition field's ID"
    field_address: String
    "The condition ID"
    id: ID
    """

    The condition operation

    Valid options:
    - equals
    - not_equals
    - present
    - blank
    - string_contains
    - string_not_contains
    - number_greater_than
    - number_less_than
    - date_is_today
    - date_is_yesterday
    - date_in_current_week
    - date_in_last_week
    - date_in_current_month
    - date_in_last_month
    - date_in_current_year
    - date_in_last_year
    - date_is
    - date_is_after
    - date_is_before
    """
    operation: String
    "The structure ID"
    structure_id: ID
    "The value or field ID to be compared"
    value: String
}

"Condition's inputs"
input ConditionInput {
    "Array with the expression inputs"
    expressions: [ConditionExpressionInput]
    "Array of arrays with the condition's order. Defining groups of \"AND\" and \"OR\""
    expressions_structure: [[ID]]
}

"Autogenerated input type of CreateCard"
input CreateCardInput {
    "The assignee IDs"
    assignee_ids: [ID]
    "The card attachments"
    attachments: [String]
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "The card due date"
    due_date: DateTime
    "Array of inputs to fill card's fields"
    fields_attributes: [FieldValueInput]
    "The label ID"
    label_ids: [ID]
    "The parent-card ID"
    parent_ids: [ID]
    "The phase ID"
    phase_id: ID
    "The pipe ID"
    pipe_id: ID!
    "The card title"
    title: String
}

"Autogenerated input type of CreateCardRelation"
input CreateCardRelationInput {
    "The child-card ID"
    childId: ID!
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "The parent-card ID"
    parentId: ID!
    "The connection ID or the field internal ID"
    sourceId: ID!
    """

    The connection sorce

    Valid options:
    - PipeRelation
    - Field
    """
    sourceType: String!
}

"Autogenerated input type of CreateComment"
input CreateCommentInput {
    "The card ID"
    card_id: ID!
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "The comment text"
    text: String!
}

"Autogenerated input type of CreateInboxEmail"
input CreateInboxEmailInput {
    "The BCC (Blind Carbon Copy) email addresses"
    bcc: [String]
    "The card ID"
    card_id: ID!
    "The CC (Carbon Copy) email addresses"
    cc: [String]
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "The email attachments"
    emailAttachments: [EmailAttachmentInput]
    "The sender email address"
    from: String!
    "The sender name"
    fromName: String
    "The sender name - deprecated"
    from_name: String
    "The email HTML"
    html: String
    "ARGUMENT IS DEPRECATED!"
    main_to: String
    "The Repo ID"
    repo_id: ID
    """

    The Inbox Email state

    Valid options:
    - 0: Pending
    - 1: Processing
    - 2: Processed
    - 3: Failed
    """
    state: String
    "The email subject"
    subject: String!
    "The email text"
    text: String
    "The email destination addresses"
    to: [String]!
    "The email creator ID"
    user_id: ID
}

"Autogenerated input type of CreateLabel"
input CreateLabelInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "The label color (hexadecimal)"
    color: String!
    "The label name"
    name: String!
    "The pipe ID"
    pipe_id: ID
    "The table ID"
    table_id: ID
}

"Autogenerated input type of CreateOrganization"
input CreateOrganizationInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    """

    The organization industry segment

    Valid options:
    - construction
    - consulting
    - education
    - energy
    - financial_services
    - health
    - legal_services
    - manufacturing
    - marketing
    - non_profit_organization
    - public_sector
    - retail
    - tourism
    - technology
    - telecommunications
    - transportation
    - others
    """
    industry: String!
    "The organization name"
    name: String!
}

"Autogenerated input type of CreateOrganizationWebhook"
input CreateOrganizationWebhookInput {
    """

    The webhook trigger(s)

    Valid options:
    - user.invitation_sent
    - user.invitation_acceptance
    - user.removal_from_org
    - user.role_set
    """
    actions: [String]!
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "The webhook's notification email"
    email: String
    "The webhook's custom headers"
    headers: Json
    "The webhook's name"
    name: String
    "The organization ID"
    organization_id: ID!
    "The webhook's notification URL"
    url: String
}

"Autogenerated input type of CreatePhaseField"
input CreatePhaseFieldInput {
    "Connection Field: Whether all children must be done to finish the parent"
    allChildrenMustBeDoneToFinishParent: Boolean
    "Connection Field: Whether all children must be done to move the parent"
    allChildrenMustBeDoneToMoveParent: Boolean
    "Connection Field: Whether can connect with existing items"
    canConnectExisting: Boolean
    "Connection Field: Whether is possible to connect with multiple items"
    canConnectMultiples: Boolean
    "Connection Field: Whether is possible to create new connected items"
    canCreateNewConnected: Boolean
    "Connection Field: Whether a child must exist to finish the parent"
    childMustExistToFinishParent: Boolean
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Connection Field: The Repo ID"
    connectedRepoId: ID
    "The regex used to validate the field's value"
    custom_validation: String
    "The field description"
    description: String
    "Whether the field is editable"
    editable: Boolean
    "The field help text"
    help: String
    "The field index"
    index: Float
    "The field title"
    label: String!
    "Whether the field is minimal"
    minimal_view: Boolean
    "The field options"
    options: [String]
    "The phase ID"
    phase_id: ID!
    "Whether the field is required"
    required: Boolean
    "Whether the field is sync with the fixed field"
    sync_with_card: Boolean
    """

    The field type

    Valid options:
    - assignee_select
    - attachment
    - checklist_horizontal
    - checklist_vertical
    - cnpj
    - connector
    - cpf
    - currency
    - date
    - datetime
    - due_date
    - email
    - id
    - label_select
    - long_text
    - number
    - phone
    - radio_horizontal
    - radio_vertical
    - select
    - short_text
    - statement
    - time
    """
    type: ID!
}

"Autogenerated input type of CreatePhase"
input CreatePhaseInput {
    "Whether cards can be created directly in the phase"
    can_receive_card_directly_from_draft: Boolean
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "The phase description"
    description: String
    "Whether it's a final phase"
    done: Boolean
    "The index where phase will be created"
    index: Float
    "The phase's SLA in seconds"
    lateness_time: Int
    "The phase name"
    name: String!
    "ARGUMENT IS DEPRECATED!"
    only_admin_can_move_to_previous: Boolean
    "The pipe ID"
    pipe_id: ID!
}

"Autogenerated input type of CreatePipe"
input CreatePipeInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Color of pipe"
    color: Colors
    """

    The pipe icon

    Valid options:
    - airplane
    - at
    - axe
    - badge
    - bag
    - boat
    - briefing
    - bug
    - bullhorn
    - calendar
    - cart
    - cat
    - chart-zoom
    - chart2
    - chat
    - check
    - checklist
    - compass
    - contract
    - dog
    - eiffel
    - emo
    - finish-flag
    - flame
    - frame
    - frog
    - game
    - github
    - globe
    - growth
    - hr-process
    - hr-requests
    - ice
    - juice
    - lamp
    - lemonade
    - liberty
    - like
    - mac
    - magic
    - map
    - message
    - mkt-requests
    - money
    - onboarding
    - pacman
    - pacman1
    - payable
    - phone
    - pipefy
    - pizza
    - planet
    - plug
    - receivables
    - receive
    - recruitment-requests
    - reload
    - rocket
    - sales
    - skull
    - snow-flake
    - star
    - target
    - task
    - task-management
    - trophy
    - underwear
    """
    icon: String
    "Array of inputs to create pipe's labels"
    labels: [LabelInput]
    "Array of inputs to invite members to the pipe"
    members: [MemberInput]
    "The pipe name"
    name: String!
    "The organization ID"
    organization_id: ID!
    "Array of inputs to create pipe's phases"
    phases: [PhaseInput]
    "The pipe preferences"
    preferences: RepoPreferenceInput
    "Array of inputs to create pipe's start form fields"
    start_form_fields: [PhaseFieldInput]
}

"Autogenerated input type of CreatePipeRelation"
input CreatePipeRelationInput {
    "Whether all children must be done to finish the parent"
    allChildrenMustBeDoneToFinishParent: Boolean!
    "Whether all children must be done to move the parent"
    allChildrenMustBeDoneToMoveParent: Boolean!
    "Whether the relation has auto fill active"
    autoFillFieldEnabled: Boolean!
    "Whether can connect with existing items"
    canConnectExistingItems: Boolean!
    "Whether is possible to connect with multiple items"
    canConnectMultipleItems: Boolean!
    "Whether is possible to create new connected items"
    canCreateNewItems: Boolean!
    "The child Repo ID"
    childId: ID!
    "Whether a child must exist to finish the parent"
    childMustExistToFinishParent: Boolean!
    "Whether a child must exist to move the parent"
    childMustExistToMoveParent: Boolean!
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "The relation name"
    name: String!
    "Array of field input to be used in the auto fill"
    ownFieldMaps: [FieldMapInput]
    "The parent Repo ID"
    parentId: ID!
}

"Autogenerated input type of CreatePresignedUrlForPipePdfTemplate"
input CreatePresignedUrlForPipePdfTemplateInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "File name"
    fileName: String!
    "The organization id"
    organizationId: ID!
    "The pipe id"
    pipeId: ID!
}

"Autogenerated input type of CreatePresignedUrl"
input CreatePresignedUrlInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "File media type"
    contentType: String
    "File name"
    fileName: String!
    "The organization id"
    organizationId: ID!
}

"Autogenerated input type of CreateTableField"
input CreateTableFieldInput {
    "Connection Field: Whether all children must be done to finish the parent"
    allChildrenMustBeDoneToFinishParent: Boolean
    "Connection Field: Whether can connect with existing items"
    canConnectExisting: Boolean
    "Connection Field: Whether is possible to connect with multiple items"
    canConnectMultiples: Boolean
    "Connection Field: Whether is possible to create new connected items"
    canCreateNewConnected: Boolean
    "Connection Field: Whether a child must exist to finish the parent"
    childMustExistToFinishParent: Boolean
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Connection Field: The Repo ID"
    connectedRepoId: ID
    "The regex used to validate the field's value"
    custom_validation: String
    "The field description"
    description: String
    "The field help text"
    help: String
    "The field title"
    label: String!
    "Whether the field is minimal"
    minimal_view: Boolean
    "The field options"
    options: [String]
    "Whether the field is required"
    required: Boolean
    "The table ID"
    table_id: ID!
    """

    The field type

    Valid options:
    - assignee_select
    - attachment
    - checklist_horizontal
    - checklist_vertical
    - cnpj
    - connector
    - cpf
    - currency
    - date
    - datetime
    - due_date
    - email
    - id
    - label_select
    - long_text
    - number
    - phone
    - radio_horizontal
    - radio_vertical
    - select
    - short_text
    - statement
    - time
    """
    type: ID!
    "Whether the field value must be unique"
    unique: Boolean
}

"Autogenerated input type of CreateTable"
input CreateTableInput {
    """

    The table authorization

    Valid options:
    - read
    - write
    """
    authorization: TableAuthorization
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Color of database"
    color: Colors
    "The table description"
    description: String
    """

    The pipe icon

    Valid options:
    - airplane
    - at
    - axe
    - badge
    - bag
    - boat
    - briefing
    - bug
    - bullhorn
    - calendar
    - cart
    - cat
    - chart-zoom
    - chart2
    - chat
    - check
    - checklist
    - compass
    - contract
    - dog
    - eiffel
    - emo
    - finish-flag
    - flame
    - frame
    - frog
    - game
    - github
    - globe
    - growth
    - hr-process
    - hr-requests
    - ice
    - juice
    - lamp
    - lemonade
    - liberty
    - like
    - mac
    - magic
    - map
    - message
    - mkt-requests
    - money
    - onboarding
    - pacman
    - pacman1
    - payable
    - phone
    - pipefy
    - pizza
    - planet
    - plug
    - receivables
    - receive
    - recruitment-requests
    - reload
    - rocket
    - sales
    - skull
    - snow-flake
    - star
    - target
    - task
    - task-management
    - trophy
    - underwear
    """
    icon: String
    "Array of inputs to create table's labels"
    labels: [LabelInput]
    "Array of inputs to invite members to the table"
    members: [MemberInput]
    "The table name"
    name: String!
    "The organization ID"
    organization_id: ID!
    "Whether the table is public"
    public: Boolean
}

"Autogenerated input type of CreateTableRecordInRestrictedTable"
input CreateTableRecordInRestrictedTableInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Array of inputs to fill record's fields"
    fieldsAttributes: [FieldValueInput]
    "The table ID"
    tableId: ID!
    "The connection field ID"
    throughConnectors: ReferenceConnectorFieldInput
}

"Autogenerated input type of CreateTableRecord"
input CreateTableRecordInput {
    "The assignee IDs"
    assignee_ids: [ID]
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "The record due date"
    due_date: DateTime
    "Array of inputs to fill record's fields"
    fields_attributes: [FieldValueInput]
    "The label ID"
    label_ids: [ID]
    "The table ID"
    table_id: ID!
    "The record title"
    title: String
}

"Autogenerated input type of CreateTableRelation"
input CreateTableRelationInput {
    "Whether all children must be done to finish the parent"
    allChildrenMustBeDoneToFinishParent: Boolean!
    "Whether all children must be done to move the parent"
    allChildrenMustBeDoneToMoveParent: Boolean!
    "Whether can connect with existing items"
    canConnectExistingItems: Boolean!
    "Whether is possible to connect with multiple items"
    canConnectMultipleItems: Boolean!
    "Whether is possible to create new connected items"
    canCreateNewItems: Boolean!
    "The child Repo ID"
    childId: ID!
    "Whether a child must exist to finish the parent"
    childMustExistToFinishParent: Boolean!
    "Whether a child must exist to move the parent"
    childMustExistToMoveParent: Boolean!
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "The relation name"
    name: String!
    "The parent Repo ID"
    parentId: ID!
}

"Autogenerated input type of CreateWebhook"
input CreateWebhookInput {
    """

    The webhook trigger(s)

    Valid options:
    - card.create
    - card.done
    - card.expired
    - card.late
    - card.move
    - card.overdue
    - card.field_update
    - card.delete
    """
    actions: [String]!
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "The webhook's notification email"
    email: String
    "The webhook's custom headers"
    headers: Json
    "The webhook's name"
    name: String!
    "The Pipe ID or SUID"
    pipe_id: ID
    "The Table ID or SUID"
    table_id: ID
    "The webhook's notification URL"
    url: String!
}

"Autogenerated input type of DeleteCard"
input DeleteCardInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "The card ID"
    id: ID!
}

"Autogenerated input type of DeleteComment"
input DeleteCommentInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "The comment ID"
    id: ID!
}

"Autogenerated input type of DeleteFieldCondition"
input DeleteFieldConditionInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "The field condition ID"
    id: ID!
}

"Autogenerated input type of DeleteInboxEmail"
input DeleteInboxEmailInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "The email ID"
    id: ID!
}

"Autogenerated input type of DeleteLabel"
input DeleteLabelInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "The label ID"
    id: ID!
}

"Autogenerated input type of DeleteOrganization"
input DeleteOrganizationInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "The organization ID"
    id: ID!
}

"Autogenerated input type of DeleteOrganizationWebhookGQLMutation"
input DeleteOrganizationWebhookGQLMutationInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "The webhook ID"
    id: ID!
}

"Autogenerated input type of DeletePhaseField"
input DeletePhaseFieldInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "The field ID"
    id: ID!
    "The UUID of the pipe the field is in"
    pipeUuid: ID
}

"Autogenerated input type of DeletePhase"
input DeletePhaseInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "The phase ID"
    id: ID!
}

"Autogenerated input type of DeletePipe"
input DeletePipeInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "The pipe ID"
    id: ID!
}

"Autogenerated input type of DeletePipeRelation"
input DeletePipeRelationInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "The relation ID"
    id: ID!
}

"Autogenerated input type of DeleteTableField"
input DeleteTableFieldInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "The field ID"
    id: ID!
    "The table ID"
    table_id: ID!
}

"Autogenerated input type of DeleteTable"
input DeleteTableInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "The table ID"
    id: ID!
}

"Autogenerated input type of DeleteTableRecord"
input DeleteTableRecordInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "The record ID"
    id: ID!
}

"Autogenerated input type of DeleteTableRelation"
input DeleteTableRelationInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "The relation ID"
    id: ID!
}

"Autogenerated input type of DeleteWebhook"
input DeleteWebhookInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "The webhook's ID"
    id: ID!
}

"Email attachment's inputs"
input EmailAttachmentInput {
    "The file name"
    fileName: String
    "The file's URL"
    fileUrl: String!
    "The file's public URL"
    publicUrl: String
}

"Email invite's inputs"
input EmailToInviteInput {
    "The email address"
    email: String!
    """

    The role name

    Valid Options:
    1. Organization
    - admin
    - normal
    - company_guest
    - external_guest
    2. Pipe
    - admin
    - member
    - creator
    - my_cards_only
    3. Table
    - admin
    - member
    """
    role_name: String!
}

"Autogenerated input type of ExportPipeReport"
input ExportPipeReportInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "The fields to be added as columns in the exported XLSX file"
    columns: [String] = []
    "The filter to be applied in this exportation"
    filter: ReportCardsFilter = {}
    "The pipe ID"
    pipeId: ID!
    "The report ID"
    pipeReportId: ID!
    "The sort direction of the results (as they will appear in the XSLX file)"
    sortBy: ReportSortDirectionInput
}

"Field condition's inputs"
input FieldConditionActionInput {
    """

    The condition action

    Valid options:
    - hide
    - show
    """
    actionId: String
    "The condition ID"
    id: ID
    "The field ID"
    phaseFieldId: ID
    "The phase for bulk actions"
    phaseId: ID
    "The validation of the conditional"
    whenEvaluator: Boolean
}

"Field map's inputs"
input FieldMapInput {
    "The parent-card field ID"
    fieldId: String!
    """

    The value input mode

    Valid options:
    - fixed_value
    - copy_from
    """
    inputMode: String!
    "The child-card field ID or the fixed value"
    value: String!
}

"Field value's inputs"
input FieldValueInput {
    "The field ID"
    field_id: ID!
    "The field value"
    field_value: [UndefinedInput]
}

"Field's column inputs"
input FieldValuesColumnsInput {
    "The spreadsheet column"
    column: String!
    "The field ID"
    fieldId: String!
}

"Filled field's inputs"
input FilledField {
    "The field ID"
    fieldId: ID!
    "The field value"
    fieldValue: [UndefinedInput]
}

"Cards search's inputs"
input FindCards {
    "The field id"
    fieldId: String!
    "The field value"
    fieldValue: String!
}

"Autogenerated input type of InviteMembers"
input InviteMembersInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Emails to be invited"
    emails: [EmailToInviteInput]!
    "A message to be sent to the invitees"
    message: String
    "The organization ID"
    organization_id: ID
    "The pipe ID"
    pipe_id: ID
    "The table ID"
    table_id: ID
}

"Label's inputs"
input LabelInput {
    "The label color (hexadecimal)"
    color: String!
    "The label name"
    name: String!
}

"Member's inputs"
input MemberInput {
    """

    The user role name

    Valid roles:
    1. Organization:
    - admin: Team admin, can view/join all pipes and access/manage the team settings;
    - normal: Team member, can view and join all public pipes;
    - company_guest: Team guest, can only create cards in authorized forms. No access to pipes or databases. Can become a Member by creating a pipe or being added to one.
    - external_guest: External guest, can only create cards in authorized forms. No access to pipes or databases.

    2. Pipe:
    - admin: Pipe admin, can create and edit cards as well as manage the pipe settings;
    - member: Pipe member, can create new cards as well as access the existing ones to edit and move them across the pipe;
    - creator: Pipe start form only, has limited access to the pipe - can create cards;
    - my_cards_only: Pipe restricted view, can create new cards but is only allowed to view/edit cards created by or assigned to him;
    - read_and_comment: Pipe read only, can view the cards and add comments.

    3. Database Table:
    - admin: Table admin, can create an edit records, edit the table and its settings;
    - member: Table member, can view and create records (if authorized on the settings).
    """
    role_name: String!
    "The user ID"
    user_id: ID!
}

"Autogenerated input type of MoveCardToPhase"
input MoveCardToPhaseInput {
    "The card ID"
    card_id: ID!
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "The phase ID"
    destination_phase_id: ID!
}

"Update field value by replacing the entire value, or adding and removing specific values."
input NodeFieldValueInput {
    "The ID of the Field."
    fieldId: ID!
    "Set the operation for the value, we allow to `replace` the entire value or use `add` or `remove` to append or remove the existing list of values, that's usefull and compatible for Labels, Assignees, Attachment, Connections and Checkbox field types. Default: `replace`"
    operation: UpdateFieldValuesOperators
    "Value that will be used to replace, add or remove based on the operation."
    value: [UndefinedInput]
}

"Phase field's inputs"
input PhaseFieldInput {
    "The field description"
    description: String
    "Whether the field is editable"
    editable: Boolean
    "The field help text"
    help: String
    "The field title"
    label: String!
    "The options of the Checklist, Radio or Select field"
    options: [String]
    "The phase ID"
    phase_id: ID
    "Whether the field is required"
    required: Boolean
    "Whether the field is sync with the fixed field"
    sync_with_card: Boolean
    """

    The field type

    Valid options:
    - assignee_select
    - attachment
    - checklist_horizontal
    - checklist_vertical
    - cnpj
    - connector
    - cpf
    - currency
    - date
    - datetime
    - due_date
    - email
    - id
    - label_select
    - long_text
    - number
    - phone
    - radio_horizontal
    - radio_vertical
    - select
    - short_text
    - statement
    - time
    """
    type_id: ID!
}

"Phase's inputs"
input PhaseInput {
    "Whether its a final phase"
    done: Boolean
    "The phase name"
    name: String!
}

"Public form settings's inputs"
input PublicFormSettingsInput {
    "The message shown to user after submitting the public form"
    afterSubmitMessage: String
    "The background color of the public form (RGB)"
    backgroundColor: String
    "The background image URL of the public form"
    backgroundImage: String
    "The brand color that will be used in the public form (RGB)"
    brandColor: String
    "Description of the public form"
    description: String
    "Whether to display Pipefy's logo in the public form"
    displayPipefyLogo: Boolean
    "Logo of the public form"
    logo: String
    "Fill again with the same values that were used on the last submission"
    reuseLastSubmissionResponse: Boolean
    "Whether its allowed to submit another response"
    showSubmitAnotherResponseButton: Boolean
    "Text of the submit button on the public form"
    submitButtonText: String
    "Whether the submitter email collection is enabled"
    submitterEmailCollectionEnabled: Boolean
    "The method to ask for the submitter email in the public form"
    submitterEmailCollectionMethod: PublicFormSubmitterEmailCollectionMethod
    "The email field from which submitter email will be collected"
    submitterEmailFieldId: ID
    "Title of the public form"
    title: String
}

"Autogenerated input type of RecordsImporter"
input RecordsImporterInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Array with the field ID and its spreadsheet column with the value"
    fieldValuesColumns: [FieldValuesColumnsInput]
    "The spreadsheet column with the record status"
    statusColumn: String
    "The table ID"
    tableId: ID!
    "The xlsx file URL"
    url: String!
}

"Connector field's inputs"
input ReferenceConnectorFieldCoreInput {
    "The field UUID"
    fieldUuid: ID!
    "The next connector field ID"
    nextConnectorField: ReferenceConnectorFieldCoreInput
}

"Connector field's inputs"
input ReferenceConnectorFieldInput {
    "The field ID"
    fieldId: ID!
    "The next connector field ID"
    nextConnectorField: ReferenceConnectorFieldInput
}

"Autogenerated input type of RemoveUserFromOrg"
input RemoveUserFromOrgInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "The user's email"
    email: String!
    "The organization id"
    organization_id: ID!
}

"Autogenerated input type of RemoveUserFromPipe"
input RemoveUserFromPipeInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "The user's email"
    email: String!
    "The Pipe id"
    pipe_id: ID
}

"Autogenerated input type of RemoveUserFromTable"
input RemoveUserFromTableInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "The user's email"
    email: String!
    "The Table id"
    table_id: ID
}

"Options to filter cards"
input RepoItemFilter {
    "Assignee to filter cards"
    cardAssigneeIds: [ID]
    "Labels to filter cards"
    cardLabelIds: [ID]
    "Text to filter cards"
    text: String
}

"Repo preference's inputs"
input RepoPreferenceInput {
    "Whether the email inbox is enable"
    inboxEmailEnabled: Boolean
    "The views selected to be shown in the cards"
    mainTabViews: [String]
}

"Card search grouped queries. May contain a number of queries or other groups of queries"
input ReportCardsFilter {
    "Groups that must be matched accordingly to the passed operator"
    groups: [ReportCardsFilter]
    "Meta data used to allow tracking of each query level"
    id: Int
    "Meta data used to allow tracking of each query level"
    lastId: Int
    "The operator for this query group"
    operator: ReportCardsFilterGroupOperators!
    "Queries that must be matched accordingly to the passed operator"
    queries: [ReportCardsFilterQuery]
}

"Card search query. Will match cards based on the chosen operator, field and value"
input ReportCardsFilterQuery {
    "The field name"
    field: String!
    "Meta data used to allow tracking of each query level"
    id: Int
    "The field internationalized label"
    label: String
    "The operator for this query"
    operator: ReportCardsFilterQueryOperators!
    "The type of the field (normally used alongside the equality operators)"
    type: ReportCardsFilterFieldTypes
    "The value to be operated on"
    value: String
}

"Defines how the report results are to be sorted"
input ReportSortDirectionInput {
    "The sort direction"
    direction: SortDirection!
    "The sort field"
    field: String!
}

"Autogenerated input type of SendInboxEmail"
input SendInboxEmailInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "The email ID"
    id: ID!
}

"Autogenerated input type of SetDismissedImprovement"
input SetDismissedImprovementInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
}

"Autogenerated input type of SetImprovementAsRead"
input SetImprovementAsReadInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    improvementSettingId: ID!
}

"Autogenerated input type of SetRole"
input SetRoleInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "The member information"
    member: MemberInput!
    "The organization ID"
    organization_id: ID
    "The pipe ID"
    pipe_id: ID
    "The table ID"
    table_id: ID
}

"Autogenerated input type of SetRoles"
input SetRolesInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Array with the user ID and role name"
    members: [MemberInput]!
    "The organization ID"
    organization_id: ID
    "The pipe ID"
    pipe_id: ID
    "The table ID"
    table_id: ID
}

"Autogenerated input type of SetSummaryAttributes"
input SetSummaryAttributesInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "The pipe ID"
    pipe_id: ID
    """

    The fields ID

    Standard options:
    - id
    - title
    - current_phase
    - labels
    - due_date
    - created_by
    - assignees
    - finished_at
    - created_at
    - updated_at
    - last_comment
    - las_comment_at
    """
    summary_attributes: [ID]!
    "The table ID"
    table_id: ID
}

"Autogenerated input type of SetTableFieldOrder"
input SetTableFieldOrderInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "The fields ID in order"
    field_ids: [ID]!
    "The table ID"
    table_id: ID!
}

"Autogenerated input type of SetTableRecordFieldValue"
input SetTableRecordFieldValueInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "The field ID"
    field_id: ID!
    "The record ID"
    table_record_id: ID!
    "The field value"
    value: [UndefinedInput]
}

"Records search's inputs"
input TableRecordSearch {
    "The assignee ID"
    assignee_ids: [ID]
    "The records ID to be ignored"
    ignore_ids: [ID]
    "Shows or not done records"
    include_done: Boolean
    "The label ID"
    label_ids: [ID]
    """

    The sort direction

    Valid options:
    - asc
    - desc
    """
    orderDirection: String
    "The field used to sort results"
    orderField: String
    "The record title"
    title: String
}

"Autogenerated input type of UpdateCardField"
input UpdateCardFieldInput {
    "The card ID"
    card_id: ID!
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "The field ID"
    field_id: ID!
    "Field new value"
    new_value: [UndefinedInput]
}

"Autogenerated input type of UpdateCard"
input UpdateCardInput {
    "The assignee IDs"
    assignee_ids: [ID]
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "The card due date"
    due_date: DateTime
    "The card ID"
    id: ID!
    "The label ID"
    label_ids: [ID]
    "The card title"
    title: String
}

"Autogenerated input type of UpdateComment"
input UpdateCommentInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "The comment ID"
    id: ID!
    "The comment text"
    text: String!
}

"Autogenerated input type of UpdateFieldCondition"
input UpdateFieldConditionInput {
    "Array with field condition's actions"
    actions: [FieldConditionActionInput]
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "The field condition's condition"
    condition: ConditionInput
    "The field condition ID"
    id: ID!
    "The field condition name"
    name: String
    "The phase ID"
    phase_id: ID
}

"Autogenerated input type of UpdateFieldsValues"
input UpdateFieldsValuesInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "The card or table record ID that will be updated."
    nodeId: ID!
    "Array of fields that you want to update with the value and operation. Limit of 30 fields per call."
    values: [NodeFieldValueInput!]!
}

"Autogenerated input type of UpdateLabel"
input UpdateLabelInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "The label color (hexadecimal)"
    color: String!
    "The label ID"
    id: ID!
    "The label name"
    name: String!
}

"Autogenerated input type of UpdateOrganization"
input UpdateOrganizationInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "The organization ID"
    id: ID!
    "The organization name"
    name: String!
    "Whether the creation of new pipes is restricted to the organization Admin"
    only_admin_can_create_pipes: Boolean
    "Whether the invitation of new users is restricted to the organization Admin"
    only_admin_can_invite_users: Boolean
}

"Autogenerated input type of UpdateOrganizationWebhook"
input UpdateOrganizationWebhookInput {
    """

    The webhook trigger

    Valid options:
    - user.invitation_sent
    - user.invitation_acceptance
    - user.removal_from_org
    - user.role_set
    """
    actions: [String]
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "The webhook's notification email"
    email: String
    "The webhook's custom headers"
    headers: Json
    "The webhook ID"
    id: ID!
    "The webhook's name"
    name: String
    "The webhook's notification URL"
    url: String
}

"Autogenerated input type of UpdatePhaseField"
input UpdatePhaseFieldInput {
    "Connection Field: Whether all children must be done to finish the parent"
    allChildrenMustBeDoneToFinishParent: Boolean
    "Connection Field: Whether all children must be done to move the parent"
    allChildrenMustBeDoneToMoveParent: Boolean
    "Connection Field: Whether can connect with existing items"
    canConnectExisting: Boolean
    "Connection Field: Whether is possible to connect with multiple items"
    canConnectMultiples: Boolean
    "Connection Field: Whether is possible to create new connected items"
    canCreateNewConnected: Boolean
    "Connection Field: Whether a child must exist to finish the parent"
    childMustExistToFinishParent: Boolean
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "The regex used to validate the field's value"
    custom_validation: String
    "The field description"
    description: String
    "Whether the field is editable"
    editable: Boolean
    "The field help text"
    help: String
    "The field ID"
    id: ID!
    "The new field index"
    index: Float
    "The field title"
    label: String!
    "Whether the field is minimal"
    minimal_view: Boolean
    "The field options"
    options: [String]
    "Whether the field is required"
    required: Boolean
    "Whether the field is sync with the fixed field"
    sync_with_card: Boolean
    "The field UUID"
    uuid: ID
}

"Autogenerated input type of UpdatePhase"
input UpdatePhaseInput {
    "Whether cards can be created directly in the phase"
    can_receive_card_directly_from_draft: Boolean
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "The phase color"
    color: Colors
    "The phase description"
    description: String
    "Whether it's a final phase"
    done: Boolean
    "The phase ID"
    id: ID!
    "The phase's SLA in seconds"
    lateness_time: Int
    "The phase name"
    name: String!
    "ARGUMENT IS DEPRECATED!"
    only_admin_can_move_to_previous: Boolean
}

"Autogenerated input type of UpdatePipe"
input UpdatePipeInput {
    "Whether all organization members can create cards in the pipe"
    anyone_can_create_card: Boolean
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Color of pipe"
    color: Colors
    "The pipe's SLA unit"
    expiration_time_by_unit: Int
    """

    The pipe's SLA expiration period

    - Minutes: 60
    - Hours: 3600
    - Day: 86400
    """
    expiration_unit: Int
    """

    The pipe icon

    Valid options:
    - airplane
    - at
    - axe
    - badge
    - bag
    - boat
    - briefing
    - bug
    - bullhorn
    - calendar
    - cart
    - cat
    - chart-zoom
    - chart2
    - chat
    - check
    - checklist
    - compass
    - contract
    - dog
    - eiffel
    - emo
    - finish-flag
    - flame
    - frame
    - frog
    - game
    - github
    - globe
    - growth
    - hr-process
    - hr-requests
    - ice
    - juice
    - lamp
    - lemonade
    - liberty
    - like
    - mac
    - magic
    - map
    - message
    - mkt-requests
    - money
    - onboarding
    - pacman
    - pacman1
    - payable
    - phone
    - pipefy
    - pizza
    - planet
    - plug
    - receivables
    - receive
    - recruitment-requests
    - reload
    - rocket
    - sales
    - skull
    - snow-flake
    - star
    - target
    - task
    - task-management
    - trophy
    - underwear
    """
    icon: String
    "The pipe ID"
    id: ID!
    "The pipe name"
    name: String
    "Noun for pipe registries"
    noun: String
    "Whether only the Admin can delete cards"
    only_admin_can_remove_cards: Boolean
    "Whether only assignee can edit the card"
    only_assignees_can_edit_cards: Boolean
    "The pipe preferences"
    preferences: RepoPreferenceInput
    "Whether the pipe is public"
    public: Boolean
    "Public form settings"
    publicFormSettings: PublicFormSettingsInput
    "Whether the public form is active"
    public_form: Boolean
    "The title field ID"
    title_field_id: ID
}

"Autogenerated input type of UpdatePipeRelation"
input UpdatePipeRelationInput {
    "Whether all children must be done to finish the parent"
    allChildrenMustBeDoneToFinishParent: Boolean!
    "Whether all children must be done to move the parent"
    allChildrenMustBeDoneToMoveParent: Boolean!
    "Whether the relation has auto fill active"
    autoFillFieldEnabled: Boolean!
    "Whether can connect with existing items"
    canConnectExistingItems: Boolean!
    "Whether is possible to connect with multiple items"
    canConnectMultipleItems: Boolean!
    "Whether is possible to create new connected items"
    canCreateNewItems: Boolean!
    "Whether a child must exist to finish the parent"
    childMustExistToFinishParent: Boolean!
    "Whether a child must exist to move the parent"
    childMustExistToMoveParent: Boolean!
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "The relation ID"
    id: ID!
    "The relation name"
    name: String!
    "Array of field input to be used in the auto fill"
    ownFieldMaps: [FieldMapInput]
}

"Autogenerated input type of UpdateTableField"
input UpdateTableFieldInput {
    "Connection Field: Whether all children must be done to finish the parent"
    allChildrenMustBeDoneToFinishParent: Boolean
    "Connection Field: Whether can connect with existing items"
    canConnectExisting: Boolean
    "Connection Field: Whether is possible to connect with multiple items"
    canConnectMultiples: Boolean
    "Connection Field: Whether is possible to create new connected items"
    canCreateNewConnected: Boolean
    "Connection Field: Whether a child must exist to finish the parent"
    childMustExistToFinishParent: Boolean
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "The regex used to validate the field's value"
    custom_validation: String
    "The field description"
    description: String
    "The field help text"
    help: String
    "The field ID"
    id: ID!
    "The field title"
    label: String
    "Whether the field is minimal"
    minimal_view: Boolean
    "The field options"
    options: [String]
    "Whether the field is required"
    required: Boolean
    "The table ID"
    table_id: ID!
    "Whether the field value must be unique"
    unique: Boolean
}

"Autogenerated input type of UpdateTable"
input UpdateTableInput {
    """

    The table authorization

    Valid options:
    - read
    - write
    """
    authorization: TableAuthorization
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Color of database"
    color: Colors
    "The create record button text"
    create_record_button_label: String
    "The table description"
    description: String
    """

    The table icon

    Valid options:
    - airplane
    - at
    - axe
    - badge
    - bag
    - boat
    - briefing
    - bug
    - bullhorn
    - calendar
    - cart
    - cat
    - chart-zoom
    - chart2
    - chat
    - check
    - checklist
    - compass
    - contract
    - dog
    - eiffel
    - emo
    - finish-flag
    - flame
    - frame
    - frog
    - game
    - github
    - globe
    - growth
    - hr-process
    - hr-requests
    - ice
    - juice
    - lamp
    - lemonade
    - liberty
    - like
    - mac
    - magic
    - map
    - message
    - mkt-requests
    - money
    - onboarding
    - pacman
    - pacman1
    - payable
    - phone
    - pipefy
    - pizza
    - planet
    - plug
    - receivables
    - receive
    - recruitment-requests
    - reload
    - rocket
    - sales
    - skull
    - snow-flake
    - star
    - target
    - task
    - task-management
    - trophy
    - underwear
    """
    icon: String
    "The table ID"
    id: ID!
    "The table name"
    name: String
    "Noun for database registries"
    noun: String
    "Whether the table is public"
    public: Boolean
    "Public form settings"
    publicFormSettings: PublicFormSettingsInput
    "Whether the public form is active"
    public_form: Boolean
    "Array with fields ID"
    summary_attributes: [ID]
    "The title field ID"
    title_field_id: ID
}

"Autogenerated input type of UpdateTableRecord"
input UpdateTableRecordInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "The record due date"
    due_date: DateTime
    "The record ID"
    id: ID!
    "The record status"
    statusId: ID
    "The record title"
    title: String
}

"Autogenerated input type of UpdateTableRelation"
input UpdateTableRelationInput {
    "Whether all children must be done to finish the parent"
    allChildrenMustBeDoneToFinishParent: Boolean!
    "Whether all children must be done to move the parent"
    allChildrenMustBeDoneToMoveParent: Boolean!
    "Whether can connect with existing items"
    canConnectExistingItems: Boolean!
    "Whether is possible to connect with multiple items"
    canConnectMultipleItems: Boolean!
    "Whether is possible to create new connected items"
    canCreateNewItems: Boolean!
    "Whether a child must exist to finish the parent"
    childMustExistToFinishParent: Boolean!
    "Whether a child must exist to move the parent"
    childMustExistToMoveParent: Boolean!
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "The relation ID"
    id: ID!
    "The relation name"
    name: String!
}

"Autogenerated input type of UpdateWebhook"
input UpdateWebhookInput {
    """

    The webhook's trigger(s)

    Valid options:
    - card.create
    - card.done
    - card.expired
    - card.late
    - card.move
    - card.overdue
    - card.field_update
    - card.delete
    """
    actions: [String]
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "The webhook's notification email"
    email: String
    "The webhook's custom headers"
    headers: Json
    "The webhook ID"
    id: ID!
    "The webhook's name"
    name: String
    "The webhook's notification URL"
    url: String
}

"Autogenerated input type of configurePublicPhaseFormLink"
input configurePublicPhaseFormLinkInput {
    cardId: ID!
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    enable: Boolean!
}

"Autogenerated input type of createFieldCondition"
input createFieldConditionInput {
    "Array with field condition's actions"
    actions: [FieldConditionActionInput]
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "The field condition's condition"
    condition: ConditionInput
    "The condition position"
    index: Float
    "The field condition name"
    name: String
    "The phase ID"
    phaseId: ID
}

"Autogenerated input type of setFieldConditionOrder"
input setFieldConditionOrderInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Array of field condition IDs"
    fieldConditionIds: [ID]!
    "The phase ID"
    phaseId: ID!
}
